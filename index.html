<html>
  <head>
    <title>Minecraft Renderer</title>
    <style>
body { margin: 0; }
canvas { display: block; width:100%;height:100%;}

    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
    <script src="js/jq.js"></script>
    <script src="js/1pc.js"></script>
    <script type="module">

import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/build/three.module.js';
import { BufferGeometryUtils } from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/utils/BufferGeometryUtils.js';
var canvas,renderer,scene,camera;


init()
animate()

class Terrain{
  constructor(options){
    this.textureAtlas=options.textureAtlas;
    this.textureRows=options.textureRows;
    this.textureCols=options.textureCols;
    this.cellSize=options.cellSize;
    this.cells={};
    this.cells_meshes={};
  }
  parseVec(x,y,z){
    return `${x}:${y}:${z}`;
  }
  computeVoxelOffset(x,y,z){
    const {cellSize} = this;
    x = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
    y = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
    z = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
    return [x,y,z]
  }
  computeCellId(x,y,z){
    const {cellSize} = this;
    const cellX = Math.floor(x / cellSize);
    const cellY = Math.floor(y / cellSize);
    const cellZ = Math.floor(z / cellSize);
    return `${cellX}:${cellY}:${cellZ}`
  }
  getCellForVoxel(x,y,z){
    return this.cells[this.computeCellId(x, y, z)];
  }
  setVoxel(x,y,z,v){
    var voxel=this.computeVoxelOffset(x,y,z);
    var cellId=this.computeCellId(x,y,z);
    if(this.cells[cellId]!=undefined){
      this.cells[cellId][this.parseVec(...voxel)]=v;
    }else{
      this.cells[cellId]={};
      this.cells[cellId][this.parseVec(...voxel)]=v;
    }
    this.cells[cellId].needsUpdate=true;
  }
  getVoxel(x,y,z){
    var voxel=this.computeVoxelOffset(x,y,z);
    var cellId=this.computeCellId(x,y,z);
    if(this.cells[cellId]!=undefined){
      var val=this.cells[cellId][this.parseVec(...voxel)];
      if(val!=undefined){
        return val;
      }else{
        return 0;
      }
    }else{
      return 0;
    }
    
  }
  updateCellGeometry(x,y,z){
    const {textureAtlas}=this;
    if(this.cells[this.parseVec(x,y,z)]==undefined || this.cells[this.parseVec(x,y,z)].needsUpdate){
      var mesh=this.cells_meshes[this.parseVec(x,y,z)];
      var geometry=this.generateCellGeometry(x,y,z);
      if(geometry!=null){
        if(mesh!=undefined){
          mesh.geometry=geometry;
        }else{
          var geometry=geometry;
          var mesh = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { map: textureAtlas, side: 0 } ) );
          scene.add(mesh)
          this.cells_meshes[this.parseVec(x,y,z)]=mesh;
        }
      }
      try{
        this.cells[this.parseVec(x,y,z)].needsUpdate=false;
      }catch(e){}
      
    }
    
  }
  generateCellGeometry(x,y,z){
    const {textureAtlas,cellSize}=this;
    var geometries=[];
    // Object.forEach(this.cells)
    for(var i=0;i<cellSize;i++){
      for(var j=0;j<cellSize;j++){
        for(var k=0;k<cellSize;k++){
          var voxelGeometries=this.generateVoxelGeometry(x*cellSize+i,y*cellSize+j,z*cellSize+k);
          // console.log(voxelGeometries)
          for(var l=0;l<voxelGeometries.length;l++){
            geometries.push(voxelGeometries[l]);
          }
          
        }
      }
    }
    // console.log(geometries)
    if(geometries.length!=0){
      var geometry = BufferGeometryUtils.mergeBufferGeometries( geometries );
      geometry.computeBoundingSphere();
    }else{
      var geometry=null;
    }
    
    
    return geometry;
  }
  generateVoxelGeometry(x,y,z){
    // console.log(x,y,z)
    var voxel=this.getVoxel(x,y,z);
    var matrix = new THREE.Matrix4();
    matrix.makeTranslation(x,y,z);
    if(voxel==1){
      var geometries=[];
      if(this.getVoxel(x-1,y,z)==0){
        var nxGeometry=this.generateFace("nx");
        geometries.push( nxGeometry.applyMatrix4( matrix ) )
      }
      if(this.getVoxel(x+1,y,z)==0){
        var pxGeometry=this.generateFace("px");
        geometries.push( pxGeometry.applyMatrix4( matrix ) )
      }
      if(this.getVoxel(x,y-1,z)==0){
        var nyGeometry=this.generateFace("ny");
        geometries.push( nyGeometry.applyMatrix4( matrix ) )
      }
      if(this.getVoxel(x,y+1,z)==0){
        var pyGeometry=this.generateFace("py");
        geometries.push( pyGeometry.applyMatrix4( matrix ) )
      }
      if(this.getVoxel(x,y,z-1)==0){
        var nzGeometry=this.generateFace("nz");
        geometries.push( nzGeometry.applyMatrix4( matrix ) )
      }
      if(this.getVoxel(x,y,z+1)==0){
        var pzGeometry=this.generateFace("pz");
        geometries.push( pzGeometry.applyMatrix4( matrix ) )
      } 
      // geometries.push( nxGeometry.applyMatrix4( matrix ) )
      // geometries.push( pxGeometry.applyMatrix4( matrix ) )
      // geometries.push( nyGeometry.applyMatrix4( matrix ) )
      // geometries.push( pyGeometry.applyMatrix4( matrix ) )
      // geometries.push( nzGeometry.applyMatrix4( matrix ) )
      // geometries.push( pzGeometry.applyMatrix4( matrix ) )
      return geometries;
    }else{
      return []
    }
  }
  generateFace(type){
    var geometry = new THREE.PlaneBufferGeometry(1, 1);
    if(type=="px"){
      geometry.rotateY( Math.PI / 2 );
      geometry.translate( 0.5, 0, 0 );
    }
    if(type=="nx"){
      geometry.rotateY( - Math.PI / 2 );
      geometry.translate( - 0.5, 0, 0 );
    }
    if(type=="py"){
      geometry.rotateX( - Math.PI / 2 );
      geometry.translate( 0, 0.5, 0 );
    }
    if(type=="ny"){
      geometry.rotateX( Math.PI / 2 );
      geometry.translate( 0, -0.5, 0 );
    }
    if(type=="pz"){
      geometry.translate( 0, 0, 0.5 );
    }
    if(type=="nz"){
      geometry.rotateY( Math.PI );
      geometry.translate( 0, 0, -0.5 );
    }
    var rx=Math.floor(Math.random()*4)
    var ry=15
    this.setUv(geometry,rx,ry,180)
    return geometry;
  }
  setUv(geometry,x,y,rotation=0){
    const {textureRows,textureCols}=this;
    var textureSizeX=1/textureRows;
    var textureSizeY=1/textureCols;
    if(rotation==0){
      geometry.attributes.uv.array[ 0 ] = textureSizeX*x;
      geometry.attributes.uv.array[ 1 ] = textureSizeY*y;

      geometry.attributes.uv.array[ 2 ] = textureSizeX+textureSizeX*x;
      geometry.attributes.uv.array[ 3 ] = 0+textureSizeY*y;

      geometry.attributes.uv.array[ 4 ] = 0+textureSizeX*x;
      geometry.attributes.uv.array[ 5 ] = textureSizeY+textureSizeY*y;

      geometry.attributes.uv.array[ 6 ] = textureSizeX+textureSizeX*x;
      geometry.attributes.uv.array[ 7 ] = textureSizeY+textureSizeY*y;
    }else if(rotation==180){
      geometry.attributes.uv.array[ 4 ] = textureSizeX*x;
      geometry.attributes.uv.array[ 5 ] = textureSizeY*y;

      geometry.attributes.uv.array[ 6 ] = textureSizeX+textureSizeX*x;
      geometry.attributes.uv.array[ 7 ] = 0+textureSizeY*y;

      geometry.attributes.uv.array[ 0 ] = 0+textureSizeX*x;
      geometry.attributes.uv.array[ 1 ] = textureSizeY+textureSizeY*y;

      geometry.attributes.uv.array[ 2 ] = textureSizeX+textureSizeX*x;
      geometry.attributes.uv.array[ 3 ] = textureSizeY+textureSizeY*y;
    }
  }
}


var texture = new THREE.TextureLoader().load( 'atla.png' );
texture.magFilter = THREE.NearestFilter;
var world=new Terrain({
  textureAtlas:texture,
  textureRows:16,
  textureCols:16,
  cellSize:16,
})

var vari=50
for (let y = 0; y < vari; ++y) {
  for (let z = 0; z < vari; ++z) {
    for (let x = 0; x < vari; ++x) {
      const height = (Math.sin(x / vari * Math.PI * 2) + Math.sin(z / vari * Math.PI * 3)) * (vari / 6) + (vari / 2);
      if (y < height) {
          world.setVoxel(x, y, z, 1);
      }
    }
  }
}
// console.log(world.cells["0:0:0"])
for(var i=0;i<5;i++){
  for(var j=0;j<5;j++){
    for(var k=0;k<5;k++){
      world.updateCellGeometry(i,j,k);
    }
  }
}

// world.generateMeshForCell(0,0,1);

function init(){
  canvas=document.querySelector('#c');
  renderer= new THREE.WebGLRenderer({
    canvas
  });

  scene = new THREE.Scene();
  scene.background = new THREE.Color('lightblue');

  camera = new THREE.PerspectiveCamera(75, 2, 0.1, 1000);
  camera.rotation.order="YXZ"
  camera.position.set(25,25,25)
  FirstPersonControls(canvas,camera,0.04)


  var ambientLight = new THREE.AmbientLight( 0xcccccc );
  scene.add( ambientLight );
}


function animate() {
  render()
  requestAnimationFrame(animate)
}

function resizeRendererToDisplaySize(renderer) {
  const canvas = renderer.domElement;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  const needResize = canvas.width !== width || canvas.height !== height;
  if (needResize) {
    renderer.setSize(width, height, false);
  }
  return needResize;
}

function render() {
  if (resizeRendererToDisplaySize(renderer)) {
    const canvas = renderer.domElement;
    camera.aspect = canvas.clientWidth / canvas.clientHeight;
    camera.updateProjectionMatrix();
  }
  renderer.render(scene, camera);
}






    </script>
  </body>
</html>