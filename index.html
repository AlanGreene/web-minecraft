
<html>
  <head>
    <title>Minecraft</title>

    <div css>
      <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.5.0/css/bootstrap.min.css">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.0/css/mdb.min.css">
      <link rel="stylesheet" href="css/main.css">
    </div>

    <div js>
      <script type="text/javascript" src="js/jq.js?1234"></script>
      <script type="text/javascript" src="js/popper.min.js?1234"></script>
      <script type="text/javascript" src="js/bootstrap.min.js?1234"></script>
      <script type="text/javascript" src="js/mdb.min.js?1234"></script>
      <script type="text/javascript" src="js/socket.io.js?1234"></script>
    </div>

  </head>
  <body>
    <canvas id="c"></canvas>
    <div class="gui">
      <div class="inventoryBar"></div>
      <div class="gameMenu">
        <div class="row">
          <div class="col-4 pl-5 pt-4">
            Web-minecraft v.1.0
          </div>
          <div class="col-4 text-center p-3">
            <h3>Gra zatrzymana</h3>
            <button class="gameOn btn btn-dark w-100">
              Graj
            </button>
            <button class="btn btn-dark w-100" onclick="document.location.reload()">
             Restart
            </button>
          </div>
          <div class="col-4 p-3">
            Kontrolki
            <li>
              W: do przodu
            </li>
            <li>
              S: do tyłu
            </li>
            <li>
              A: w lewo
            </li>
            <li>
              D: w prawo
            </li>
            <li>
              Spacja: do góry
            </li>
            <li>
              Left Shift: do dołu
            </li>
            <li>
              Klawisze 1,2,3: Zmiana trzymającego itemu
            </li>

          </div>
        </div>
      </div>
      <div class="cross">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
          <line x1="15" y1="0" x2="15" y2="30" stroke="black" stroke-width="1" />
          <line x1="0" y1="15" x2="30" y2="15" stroke="black" stroke-width="1" />
        </svg>
      </div>
    </div>
    <script type="module">
import * as THREE from './module/build/three.module.js';
import {BufferGeometryUtils} from './module/jsm/utils/BufferGeometryUtils.js';
import Stats from './module/jsm/libs/stats.module.js';
import {FBXLoader} from './module/jsm/loaders/FBXLoader.js';

class Terrain {
  constructor(options) {
    this.textureAtlas = options.textureAtlas;
    this.textureRows = options.textureRows;
    this.textureCols = options.textureCols;
    this.cellSize = options.cellSize;
    this.cells = {};
    this.cells_meshes = {};
    this.neighbours = [
      [-1, 0, 0],
      [1, 0, 0],
      [0, -1, 0],
      [0, 1, 0],
      [0, 0, -1],
      [0, 0, 1]
    ],
    this.blocks = {
      0: {
        isSolid:false
      },
      1: {
        name:"grass",
        isSolid:true,
        faces: {
          nx: [3, 15],
          ny: [2, 15],
          nz: [3, 15],
          px: [3, 15],
          py: [0, 15],
          pz: [3, 15]
        }
      },
      2: {
        name:"stone",
        isSolid:true,
        faces: {
          nx: [1, 15],
          ny: [1, 15],
          nz: [1, 15],
          px: [1, 15],
          py: [1, 15],
          pz: [1, 15]
        }
      },
      3: {
        name:"wood",
        isSolid:true,
        faces: {
          nx: [4, 15],
          ny: [4, 15],
          nz: [4, 15],
          px: [4, 15],
          py: [4, 15],
          pz: [4, 15]
        }
      },
      4: {
        name:"stairs",
        isSolid:false,
      },
      5: {
        name:"stairs",
        isSolid:false,
      },
      6: {
        name:"brick",
        isSolid:true,
        faces: {
          nx: [7, 15],
          ny: [7, 15],
          nz: [7, 15],
          px: [7, 15],
          py: [7, 15],
          pz: [7, 15]
        }
      },
      7: {
        name:"furnace",
        isSolid:true,
        faces: {
          nx: [13, 13],
          ny: [13, 13],
          nz: [13, 13],
          px: [12, 13],
          py: [14,12],
          pz: [13,13]
        }
      },
      8: {
        name:"library",
        isSolid:true,
        faces: {
          nx: [3, 13],
          ny: [4, 15],
          nz: [3, 13],
          px: [3, 13],
          py: [4,15],
          pz: [3,13]
        }
      },
      9: {
        name:"tnt",
        isSolid:true,
        faces: {
          nx: [8, 15],
          ny: [10, 15],
          nz: [8, 15],
          px: [8, 15],
          py: [9, 15],
          pz: [8, 15]
        }
      }
    }
  }
  parseVec(x, y, z) {
    return `${x}:${y}:${z}`;
  }
  computeVoxelOffset(x, y, z) {
    const {
      cellSize
    } = this;
    x = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
    y = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
    z = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
    return [x, y, z]
  }
  computeCellId(x, y, z) {
    const {
      cellSize
    } = this;
    const cellX = Math.floor(x / cellSize);
    const cellY = Math.floor(y / cellSize);
    const cellZ = Math.floor(z / cellSize);
    return this.parseVec(cellX,cellY,cellZ)
  }
  getCellForVoxel(x, y, z) {
    return this.cells[this.computeCellId(x, y, z)];
  }
  setVoxel(x, y, z, v) {
    var voxel = this.computeVoxelOffset(x, y, z);
    var cellId = this.computeCellId(x, y, z);
    if (this.cells[cellId] != undefined) {
      this.cells[cellId][this.parseVec(...voxel)] = v;
    } else {
      this.cells[cellId] = {
        [this.parseVec(...voxel)]: v
      };
    }
    this.cells[cellId].needsUpdate = true;
    // console.log(this.neighbours)
    for (var i = 0; i < this.neighbours.length; i++) {
      var neigh = this.neighbours[i];
      var cellIdX = this.computeCellId(x + neigh[0], y + neigh[1], z + neigh[2]);
      try {
        this.cells[cellIdX].needsUpdate = true;
      } catch (e) {}

    }
  }
  getVoxel(x, y, z) {
    var voxel = this.computeVoxelOffset(x, y, z);
    var cellId = this.computeCellId(x, y, z);
    if (this.cells[cellId] != undefined) {
      var val = this.cells[cellId][this.parseVec(...voxel)];
      if (val != undefined) {
        return val;
      } else {
        return 0;
      }
    } else {
      return 0;
    }
  }
  updateCells() {
    const {
      cells
    } = this;
    Object.keys(cells).forEach(function (id) {
      if (cells[id].needsUpdate) {
        world.updateCellGeometry(...id.split(":"))
      }
    })
  }
  updateCellGeometry(x, y, z) {
    console.warn(`updating Chunk: ${x}:${y}:${z}`)
    const {
      textureAtlas
    } = this;
    if (this.cells[this.parseVec(x, y, z)].needsUpdate) {
      var mesh = this.cells_meshes[this.parseVec(x, y, z)];
      var geometry = this.generateCellGeometry(x, y, z);
      if (geometry != null) {
        geometry.dynamic = false;
        if (mesh != undefined) {
          mesh.geometry = geometry;
        } else {
          var geometry = geometry;
          var mesh = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({
            map: textureAtlas,
            side: 0
          }));
          // mesh.computeAngleVertexNormals(Math.PI/2);
          scene.add(mesh)
          this.cells_meshes[this.parseVec(x, y, z)] = mesh;
        }
      } else {
        scene.remove(this.cells_meshes[this.parseVec(x, y, z)])
        delete this.cells_meshes[this.parseVec(x, y, z)]
        // delete this.cells[this.parseVec(x,y,z)]
      }
      try {
        this.cells[this.parseVec(x, y, z)].needsUpdate = false;
      } catch (e) {}

    }
  }
  generateCellGeometry(x, y, z) {
    const {
      textureAtlas,
      cellSize
    } = this;
    var geometries = [];
    for (var i = 0; i < cellSize; i++) {
      for (var j = 0; j < cellSize; j++) {
        for (var k = 0; k < cellSize; k++) {
          var voxelGeometries = this.generateVoxelGeometry(x * cellSize + i, y * cellSize + j, z * cellSize + k);
          for (var l = 0; l < voxelGeometries.length; l++) {
            if(voxelGeometries[l].index!=null){
              voxelGeometries[l]=voxelGeometries[l].toNonIndexed()
            }
            geometries.push(voxelGeometries[l]);

          }
        }
      }
    }
    if (geometries.length != 0) {
      var geometry = BufferGeometryUtils.mergeBufferGeometries(geometries);
      geometry.computeBoundingSphere();
      geometry.computeVertexNormals();
    } else {
      var geometry = null;
    }
    return geometry;
  }
  generateVoxelGeometry(x, y, z) {
    var voxel = this.getVoxel(x, y, z);
    var matrix = new THREE.Matrix4();
    matrix.makeTranslation(x, y, z);
    if(voxel==4){
      var geo=stairsGeometry.clone()
      geo=geo.applyMatrix4(matrix)
      geo.translate(0,-0.25,0)
      return [geo]
    }else if(voxel==5){
      var geo=anvilGeometry.clone()
      geo=geo.applyMatrix4(matrix)
      geo.translate(0,-0.25,0)
      return [geo]
    }else{
      if (voxel!=0 && voxel!=4) {
        var geometries = [];
        if (!this.blocks[this.getVoxel(x - 1, y, z)].isSolid) {
          var nxGeometry = this.generateFace("nx", voxel);
          geometries.push(nxGeometry.applyMatrix4(matrix))
        }
        if (!this.blocks[this.getVoxel(x + 1, y, z)].isSolid) {
          var pxGeometry = this.generateFace("px", voxel);
          geometries.push(pxGeometry.applyMatrix4(matrix))
        }
        if (!this.blocks[this.getVoxel(x, y - 1, z)].isSolid) {
          var nyGeometry = this.generateFace("ny", voxel);
          geometries.push(nyGeometry.applyMatrix4(matrix))
        }
        if (!this.blocks[this.getVoxel(x, y + 1, z)].isSolid) {
          var pyGeometry = this.generateFace("py", voxel);
          geometries.push(pyGeometry.applyMatrix4(matrix))
        }
        if (!this.blocks[this.getVoxel(x, y, z - 1)].isSolid) {
          var nzGeometry = this.generateFace("nz", voxel);
          geometries.push(nzGeometry.applyMatrix4(matrix))
        }
        if (!this.blocks[this.getVoxel(x, y, z + 1)].isSolid) {
          var pzGeometry = this.generateFace("pz", voxel);
          geometries.push(pzGeometry.applyMatrix4(matrix))
        }
        return geometries; 
      } else {
        return []
      }
    }
  }
  generateFace(type, voxel) {
    var geometry = new THREE.PlaneBufferGeometry(1, 1);
    var light = new THREE.Color( 0xffffff );
    var shadow = new THREE.Color( 0x505050 );
    if (type == "px") {
      geometry.rotateY(Math.PI / 2);
      geometry.translate(0.5, 0, 0);
    }
    if (type == "nx") {
      geometry.rotateY(-Math.PI / 2);
      geometry.translate(-0.5, 0, 0);
    }
    if (type == "py") {
      geometry.rotateX(-Math.PI / 2);
      geometry.translate(0, 0.5, 0);
    }
    if (type == "ny") {
      geometry.rotateX(Math.PI / 2);
      geometry.translate(0, -0.5, 0);
    }
    if (type == "pz") {
      geometry.translate(0, 0, 0.5);
    }
    if (type == "nz") {
      geometry.rotateY(Math.PI);
      geometry.translate(0, 0, -0.5);
    }
    var uv = this.blocks[voxel]["faces"][type]

    this.setUv(geometry, uv[0], uv[1], 180)
    return geometry;
  }
  setUv(geometry, x, y, rotation = 0) {
    const {
      textureRows,
      textureCols
    } = this;
    var textureSizeX = 1 / textureRows;
    var textureSizeY = 1 / textureCols;
    if (rotation == 0) {
      geometry.attributes.uv.array[0] = textureSizeX * x;
      geometry.attributes.uv.array[1] = textureSizeY * y;

      geometry.attributes.uv.array[2] = textureSizeX + textureSizeX * x;
      geometry.attributes.uv.array[3] = 0 + textureSizeY * y;

      geometry.attributes.uv.array[4] = 0 + textureSizeX * x;
      geometry.attributes.uv.array[5] = textureSizeY + textureSizeY * y;

      geometry.attributes.uv.array[6] = textureSizeX + textureSizeX * x;
      geometry.attributes.uv.array[7] = textureSizeY + textureSizeY * y;
    } else if (rotation == 180) {
      geometry.attributes.uv.array[4] = textureSizeX * x;
      geometry.attributes.uv.array[5] = textureSizeY * y;

      geometry.attributes.uv.array[6] = textureSizeX + textureSizeX * x;
      geometry.attributes.uv.array[7] = 0 + textureSizeY * y;

      geometry.attributes.uv.array[0] = 0 + textureSizeX * x;
      geometry.attributes.uv.array[1] = textureSizeY + textureSizeY * y;

      geometry.attributes.uv.array[2] = textureSizeX + textureSizeX * x;
      geometry.attributes.uv.array[3] = textureSizeY + textureSizeY * y;
    }
  }
  intersectsRay(start,end){
    start.x+=0.5;
    start.y+=0.5;
    start.z+=0.5;
    end.x+=0.5;
    end.y+=0.5
    end.z+=0.5
    let dx = end.x - start.x;
    let dy = end.y - start.y;
    let dz = end.z - start.z;
    const lenSq = dx * dx + dy * dy + dz * dz;
    const len = Math.sqrt(lenSq);

    dx /= len;
    dy /= len;
    dz /= len;

    let t = 0.0;
    let ix = Math.floor(start.x);
    let iy = Math.floor(start.y);
    let iz = Math.floor(start.z);
    const stepX = (dx > 0) ? 1 : -1;
    const stepY = (dy > 0) ? 1 : -1;
    const stepZ = (dz > 0) ? 1 : -1;

    const txDelta = Math.abs(1 / dx);
    const tyDelta = Math.abs(1 / dy);
    const tzDelta = Math.abs(1 / dz);

    const xDist = (stepX > 0) ? (ix + 1 - start.x) : (start.x - ix);
    const yDist = (stepY > 0) ? (iy + 1 - start.y) : (start.y - iy);
    const zDist = (stepZ > 0) ? (iz + 1 - start.z) : (start.z - iz);

    let txMax = (txDelta < Infinity) ? txDelta * xDist : Infinity;
    let tyMax = (tyDelta < Infinity) ? tyDelta * yDist : Infinity;
    let tzMax = (tzDelta < Infinity) ? tzDelta * zDist : Infinity;

    let steppedIndex = -1;
    while (t <= len) {
      const voxel = this.getVoxel(ix, iy, iz);
      if (voxel) {
        return {
          position: [
            start.x + t * dx,
            start.y + t * dy,
            start.z + t * dz,
          ],
          normal: [
            steppedIndex === 0 ? -stepX : 0,
            steppedIndex === 1 ? -stepY : 0,
            steppedIndex === 2 ? -stepZ : 0,
          ],
          voxel,
        };
      }
      if (txMax < tyMax) {
        if (txMax < tzMax) {
          ix += stepX;
          t = txMax;
          txMax += txDelta;
          steppedIndex = 0;
        } else {
          iz += stepZ;
          t = tzMax;
          tzMax += tzDelta;
          steppedIndex = 2;
        }
      } else {
        if (tyMax < tzMax) {
          iy += stepY;
          t = tyMax;
          tyMax += tyDelta;
          steppedIndex = 1;
        } else {
          iz += stepZ;
          t = tzMax;
          tzMax += tzDelta;
          steppedIndex = 2;
        }
      }
    }
    return null;
  }
}

class InventoryBar {
  constructor(options) {
    this.boxSize = options.boxSize;
    this.div = options.div;
    this.padding = options.padding;
    this.boxes = options.boxes;
    this.setup()
    this.activeBox = options.activeBox
  }
  setup() {
    const {
      boxes,
      boxSize,
      padding
    } = this;
    console.warn("InventoryBar created!")
    var result = ``;
    for (var i = 0; i < boxes; i++) {
      result += `<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" width=${boxSize} height=${boxSize} style="border:1px solid black" alt="">`
    }
    $(this.div).html(result);
    $(this.div).attr(`style`, `position:fixed;bottom:3px;left:50%;width:${(boxSize+2)*boxes}px;margin-left:-${boxSize*boxes/2}px;height:${boxSize}px;`)
  }
  setBox(number, imageSrc) {
    if (imageSrc == null) {
      imageSrc = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII="
    }
    $(`${this.div} img`).eq(number - 1).attr("src", imageSrc)
  }
  setFocus(number, state) {
    if (state) {
      $(`${this.div} img`).eq(number - 1).css("background", "rgba(0,0,0,0.7)")
      $(`${this.div} img`).eq(number - 1).css("border", "1px solid black")
    } else {
      $(`${this.div} img`).eq(number - 1).css("background", "rgba(54,54,54,0.5)")
      $(`${this.div} img`).eq(number - 1).css("border", "1px solid #363636")
    }
  }
  setFocusOnly(number) {
    const {
      boxes
    } = this;
    for (var i = 1; i <= boxes; i++) {
      this.setFocus(i, i == number)
    }
    this.activeBox = number
  }
  moveBoxMinus() {
    if (this.activeBox + 1 > this.boxes) {
      this.setFocusOnly(1);
    } else {
      this.setFocusOnly(this.activeBox + 1);
    }
  }
  moveBoxPlus() {
    if (this.activeBox - 1 == 0) {
      this.setFocusOnly(this.boxes);
    } else {
      this.setFocusOnly(this.activeBox - 1);
    }
  }
  directBoxChange(event) {
    var code = event.keyCode
    if (code >= 49 && code < 49 + this.boxes) {
      this.setFocusOnly(code - 48)
    }
  }
}

class FirstPersonControls {
  constructor(options) {
    this.kc = {
      "w": 87,
      "s": 83,
      "a": 65,
      "d": 68,
      "space": 32,
      "shift": 16
    };
    this.keys = {}
    this.canvas = options.canvas
    this.camera = options.camera;
    this.micromove = options.micromove
  }
  ac(qx, qy, qa, qf) {
    var m_x = -Math.sin(qa) * qf;
    var m_y = -Math.cos(qa) * qf;
    var r_x = qx - m_x;
    var r_y = qy - m_y;
    return {
      x: r_x,
      y: r_y
    };
  }
  degtorad(deg) {
    return deg * Math.PI / 180;
  }
  radtodeg(rad) {
    return rad * 180 / Math.PI;
  }
  camMicroMove() {
    if (this.keys[this.kc["w"]]) {
      this.camera.position.x = this.ac(this.camera.position.x, this.camera.position.z, this.camera.rotation.y + this.degtorad(180), this.micromove).x;
      this.camera.position.z = this.ac(this.camera.position.x, this.camera.position.z, this.camera.rotation.y + this.degtorad(180), this.micromove).y;
    }
    if (this.keys[this.kc["s"]]) {
      this.camera.position.x = this.ac(this.camera.position.x, this.camera.position.z, this.camera.rotation.y, this.micromove).x;
      this.camera.position.z = this.ac(this.camera.position.x, this.camera.position.z, this.camera.rotation.y, this.micromove).y;
    }
    if (this.keys[this.kc["a"]]) {
      this.camera.position.x = this.ac(this.camera.position.x, this.camera.position.z, this.camera.rotation.y - this.degtorad(90), this.micromove).x;
      this.camera.position.z = this.ac(this.camera.position.x, this.camera.position.z, this.camera.rotation.y - this.degtorad(90), this.micromove).y;
    }
    if (this.keys[this.kc["d"]]) {
      this.camera.position.x = this.ac(this.camera.position.x, this.camera.position.z, this.camera.rotation.y + this.degtorad(90), this.micromove).x;
      this.camera.position.z = this.ac(this.camera.position.x, this.camera.position.z, this.camera.rotation.y + this.degtorad(90), this.micromove).y;
    }
    if (this.keys[this.kc["space"]]) {
      this.camera.position.y += this.micromove;
    }
    if (this.keys[this.kc["shift"]]) {
      this.camera.position.y -= this.micromove;
    }
  }
  lockPointer() {
    this.canvas.requestPointerLock()
  }
}


var canvas,renderer,scene,camera,stats,raycaster,
  gameState,stairsGeometry,world,cube,FPC,anvilGeometry,socket,playerObject;

init()
animate()

function init(){
  socket=io.connect("https://d93db05c1da1.ngrok.io/");
  socket.on("connect",()=>{
    console.log("Połączono z serverem socketio")
    socket.emit("siemka","siemka")

  })
  socket.on("firstLoad",function (v){
    console.log("Otrzymano pakiet świata!")
    replaceWorld(v)
  })
  socket.on("blockUpdate",function (block){
    world.setVoxel(...block)
  })
  var playersx={}
  socket.on("playerUpdate",function (players){
    var sockets={};
    Object.keys(players).forEach(function (p){
      sockets[p]=true;
      if(playersx[p]==undefined && p!=socket.id){
        loader.load( 'assets/models/player.fbx', function ( object ) {
          var texturex = new THREE.TextureLoader().load('assets/textures/steve.png');
          console.log("Creating new player:"+p)
          texturex.magFilter = THREE.NearestFilter;
          object.children[1].scale.set(1,1,1)
          object.children[1].position.set(25,25,25)
          object.children[0].material.map=texturex
          object.children[0].material.color=new THREE.Color( 0xffffff );
          object.children[1].scale.set(0.5,0.5,0.5)
          scene.add(object)
          playersx[p]=object;
        });
      }
      try{
        playersx[p].children[1].position.set(players[p].x,players[p].y-0.5,players[p].z)
        playersx[p].children[1].children[0].children[0].children[0].children[2].rotation.x=players[p].xyaw;
        playersx[p].children[1].children[0].rotation.z=players[p].zyaw
      }catch(e){}
      
      // setInterval(function (){
      //       object.children[1].children[0].children[0].children[0].children[2].rotation.x=-camera.rotation.x
      //       object.children[1].children[0].rotation.z=camera.rotation.y+Math.PI
      //     })
    })
    // console.log(players)
    Object.keys(playersx).forEach(function (p){
      if(sockets[p]==undefined){
        scene.remove(playersx[p]);
        delete playersx[p]
      }
    })
  })
  canvas = document.querySelector('#c');
  renderer = new THREE.WebGLRenderer({
    canvas
  });

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xb0b0b0);
  const color = new THREE.Color(0xb0b0b0);
  const density = 0.01;
  scene.fog = new THREE.FogExp2(color, density);

  camera = new THREE.PerspectiveCamera(75, 2, 0.1, 1000);
  camera.rotation.order = "YXZ"
  camera.position.set(26, 26, 26)
  stats = new Stats();
  stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
  document.body.appendChild(stats.dom);

  var ambientLight = new THREE.AmbientLight(0xcccccc);
  scene.add(ambientLight);
  var directionalLight = new THREE.DirectionalLight(0x333333, 2);
  directionalLight.position.set(1, 1, 0.5).normalize();
  scene.add(directionalLight);

  raycaster = new THREE.Raycaster();

  var texture = new THREE.TextureLoader().load('assets/textures/Terrain.png');
  texture.magFilter = THREE.NearestFilter;

  gameState="menu";

  var loader = new FBXLoader();
  loader.load( 'assets/models/clouds.fbx', function ( object ) {
    object.scale.x=0.1
    object.scale.y=0.1
    object.scale.z=0.1
    object.position.y=100
    scene.add( object );
  } );
  loader.load( 'assets/models/stairso.fbx', function ( object ) {
    stairsGeometry=object.children[0].geometry
    stairsGeometry.scale(10,10,10)
  });
  loader.load( 'assets/models/anvil.fbx', function ( object ) {
    anvilGeometry=object.children[0].geometry
    anvilGeometry.scale(1,1,1)
    anvilGeometry.rotateX(-Math.PI/2)
    anvilGeometry.translate(0,0.17,0)
  });

  // loader.load( 'assets/models/player.fbx', function ( object ) {
  //   // object.scale.set(0.01,0.01,0.01)
  //   // console.log(object)
  //   var texturex = new THREE.TextureLoader().load('assets/textures/steve.png');
  //   texturex.magFilter = THREE.NearestFilter;

  //   object.children[1].scale.set(1,1,1)
  //   object.children[1].position.set(25,25,25)
  //   object.children[0].material.map=texturex
  //   object.children[0].material.color=new THREE.Color( 0xffffff );
  //   object.children[1].scale.set(0.5,0.5,0.5)
  //   setInterval(function (){
  //     object.children[1].children[0].children[0].children[0].children[2].rotation.x=-camera.rotation.x
  //     object.children[1].children[0].rotation.z=camera.rotation.y+Math.PI
  //   })
  //   scene.add(object)
  // });

  world = new Terrain({
    textureAtlas: texture,
    textureRows: 16,
    textureCols: 16,
    cellSize: 16,
  })
  // var vari=50
  // for (let y = 0; y < vari; ++y) {
  //   for (let z = 0; z < vari; ++z) {
  //     for (let x = 0; x < vari; ++x) {
  //       const height = (Math.sin(x / vari * Math.PI * 2) + Math.sin(z / vari * Math.PI * 3)) * (vari / 6) + (vari / 2);
  //       if (y < height) {
  //         world.setVoxel(x, y, z, 2);
  //       }
  //     }
  //   }
  // }
  var inv_bar = new InventoryBar({
    boxSize: 60,
    boxes: 9,
    padding: 4,
    div: ".inventoryBar",
    activeBox: 1
  })
  inv_bar.setBox(1,"https://gamepedia.cursecdn.com/minecraft_gamepedia/6/6a/Grass_Block_JE6_BE5.png")
  inv_bar.setBox(2,"https://gamepedia.cursecdn.com/minecraft_gamepedia/2/29/Stone_JE4_BE2.png")
  inv_bar.setBox(3,"https://gamepedia.cursecdn.com/minecraft_gamepedia/3/37/Oak_Planks_JE6_BE3.png")
  inv_bar.setBox(4,"https://gamepedia.cursecdn.com/minecraft_gamepedia/archive/e/e0/20200317210502%21Stone_Brick_Stairs_JE3_BE2.png?version=29cb53ead07bbd3a08d158397d1078d5")
  inv_bar.setBox(5,"https://vignette.wikia.nocookie.net/minecraft/images/4/4e/AnvilNew.png/revision/latest?cb=20200226224259")
  inv_bar.setBox(6,"https://gamepedia.cursecdn.com/minecraft_gamepedia/6/62/Bricks_JE5_BE3.png")
  inv_bar.setBox(7,"https://gamepedia.cursecdn.com/minecraft_pl_gamepedia/c/c0/Furnace_przed_Texture_Update.png")
  inv_bar.setBox(8,"https://gamepedia.cursecdn.com/minecraft_gamepedia/0/05/Bookshelf_JE4_BE2.png")
  inv_bar.setBox(9,"https://gamepedia.cursecdn.com/minecraft_pl_gamepedia/1/1e/TNT.png")
  inv_bar.setFocusOnly(1)

  $(window).on('wheel', function (event) {
    if (event.originalEvent.deltaY < 0) {
      inv_bar.moveBoxPlus()
    } else {
      inv_bar.moveBoxMinus()
    }
  })

  FPC = new FirstPersonControls({
    canvas: document.getElementById("c"),
    camera,
    micromove: 0.3
  })
  function updatePosition(e) {
    FPC.camera.rotation.x -= FPC.degtorad(e.movementY / 10)
    FPC.camera.rotation.y -= FPC.degtorad(e.movementX / 10)
    if (FPC.radtodeg(FPC.camera.rotation.x) < -90) {
      FPC.camera.rotation.x = FPC.degtorad(-90)
    }
    if (FPC.radtodeg(FPC.camera.rotation.x) > 90) {
      FPC.camera.rotation.x = FPC.degtorad(90)
    }
  }

  function lockChangeAlert() {
    if (document.pointerLockElement === canvas || document.mozPointerLockElement === canvas) {
      document.addEventListener("mousemove", updatePosition, false);
      $(".gameMenu").css("display", "none")
      gameState="game"
    } else {
      document.removeEventListener("mousemove", updatePosition, false);
      $(".gameMenu").css("display", "block")
      gameState="menu"
    }
  }
  document.addEventListener('pointerlockchange', lockChangeAlert, false);
  document.addEventListener('mozpointerlockchange', lockChangeAlert, false);
  $(document).keydown(function (z) {
    FPC.keys[z.keyCode] = true;
    inv_bar.directBoxChange(z)
  })
  $(document).keyup(function (z) {
    delete FPC.keys[z.keyCode];
  })
  $(".gameOn").click(function () {
    FPC.lockPointer()
  })

  var geometry = new THREE.BoxGeometry(1, 1, 1);
  var material = new THREE.MeshBasicMaterial({
    color: 0x00ff00
  });
  var edges = new THREE.EdgesGeometry(geometry);
  cube = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({
    color: 0x000000,
    linewidth: 0.5
  }));
  scene.add(cube);
  $(document).mousedown(function (e) {
    if (gameState=="game") {
      const start = new THREE.Vector3().setFromMatrixPosition(camera.matrixWorld);
      const end = new THREE.Vector3().set(0,0, 1).unproject(camera);
      const intersection = world.intersectsRay(start, end);
      if (e.which == 1) {
        var voxelId=0;
      } else {
        var voxelId=inv_bar.activeBox;
      }
      if(intersection){
        const pos = intersection.position.map((v, ndx) => {
          return v + intersection.normal[ndx] * (voxelId > 0 ? 0.5 : -0.5);
        });
        // world.setVoxel(...pos, voxelId);
        socket.emit("blockUpdate",[...pos,voxelId])
      }
    }
  })
}



function updateCursor(){
  const start = new THREE.Vector3().setFromMatrixPosition(camera.matrixWorld);
  const end = new THREE.Vector3().set(0,0, 1).unproject(camera);
  const intersection = world.intersectsRay(start, end);
  if(intersection){
    const pos = intersection.position.map((v, ndx) => {
      return v + intersection.normal[ndx] * -0.5;
    });
    pos[0]=Math.floor(pos[0])
    pos[1]=Math.floor(pos[1])
    pos[2]=Math.floor(pos[2])
    cube.position.set(...pos)
    // console.log(pos)
    cube.visible=true;
  }else{
    cube.visible=false;
  }
}

function replaceWorld(voxels){
  Object.keys(voxels).forEach(function (id){
    // console.log(id)
    if(voxels[id]!=world.getVoxel(...id.split(":"))){
      world.setVoxel(...id.split(":"),voxels[id]);
    }
  })
}

function animate() {
  stats.begin();
  render()
  stats.end();
  requestAnimationFrame(animate)
}

function resizeRendererToDisplaySize(renderer) {
  const canvas = renderer.domElement;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  const needResize = canvas.width !== width || canvas.height !== height;
  if (needResize) {
    renderer.setSize(width, height, false);
  }
  return needResize;
}

function render() {
  if (resizeRendererToDisplaySize(renderer)) {
    const canvas = renderer.domElement;
    camera.aspect = canvas.clientWidth / canvas.clientHeight;
    camera.updateProjectionMatrix();
  }
  if (gameState=="game") {
    socket.emit("playerUpdate",{
      x:camera.position.x,
      y:camera.position.y,
      z:camera.position.z,
      xyaw:-camera.rotation.x,
      zyaw:camera.rotation.y+Math.PI
    })
    FPC.camMicroMove()

  }
  renderer.render(scene, camera);
  world.updateCells()
  updateCursor()
  
}
    </script>
  </body>
</html>