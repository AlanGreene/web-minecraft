<html>
  <head>
    <title>Minecraft Renderer</title>
    <style>
body { margin: 0; }
canvas { display: block; width:100%;height:100%;}

    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
    <script src="js/jq2.js"></script>
    <script src="js/1pc.js"></script>
    <script type="module">

import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/build/three.module.js';
import { BufferGeometryUtils } from 'https://threejsfundamentals.org/threejs/resources/threejs/r115/examples/jsm/utils/BufferGeometryUtils.js';
var canvas,renderer,scene,camera,raycaster;


canvas=document.querySelector('#c');
renderer= new THREE.WebGLRenderer({
  canvas
});

scene = new THREE.Scene();
scene.background = new THREE.Color('lightblue');
scene.fog= new THREE.Fog(new THREE.Color('lightblue'),0.0025, 100)

camera = new THREE.PerspectiveCamera(75, 2, 0.1, 1000);
camera.rotation.order="YXZ"
camera.position.set(25,25,25)
FirstPersonControls(canvas,camera,0.07)


var ambientLight = new THREE.AmbientLight( 0xcccccc );
scene.add( ambientLight );
raycaster = new THREE.Raycaster();
var mouse = {x:0,y:0};

animate()

class Terrain{
  constructor(options){
    this.textureAtlas=options.textureAtlas;
    this.textureRows=options.textureRows;
    this.textureCols=options.textureCols;
    this.cellSize=options.cellSize;
    this.cells={};
    this.cells_meshes={};
    this.neighbours=[
      [-1,0,0],
      [1,0,0],
      [0,-1,0],
      [0,1,0],
      [0,0,-1],
      [0,0,1]]
  }
  parseVec(x,y,z){
    return `${x}:${y}:${z}`;
  }
  computeVoxelOffset(x,y,z){
    const {cellSize} = this;
    x = THREE.MathUtils.euclideanModulo(x, cellSize) | 0;
    y = THREE.MathUtils.euclideanModulo(y, cellSize) | 0;
    z = THREE.MathUtils.euclideanModulo(z, cellSize) | 0;
    return [x,y,z]
  }
  computeCellId(x,y,z){
    const {cellSize} = this;
    const cellX = Math.floor(x / cellSize);
    const cellY = Math.floor(y / cellSize);
    const cellZ = Math.floor(z / cellSize);
    return `${cellX}:${cellY}:${cellZ}`
  }
  getCellId(x,y,z){
    const {cellSize} = this;
    const cellX = Math.floor(x / cellSize);
    const cellY = Math.floor(y / cellSize);
    const cellZ = Math.floor(z / cellSize);
    return [cellX,cellY,cellZ]
  }
  getCellForVoxel(x,y,z){
    return this.cells[this.computeCellId(x, y, z)];
  }
  setVoxel(x,y,z,v){
    var voxel=this.computeVoxelOffset(x,y,z);
    var cellId=this.computeCellId(x,y,z);
    if(this.cells[cellId]!=undefined){
      this.cells[cellId][this.parseVec(...voxel)]=v;
    }else{
      this.cells[cellId]={};
      this.cells[cellId][this.parseVec(...voxel)]=v;
    }
    this.cells[cellId].needsUpdate=true;
    for(var i=0;i<this.neighbours;i++){
      var neigh=this.neighbours[i];
      cellIdX=this.computeCellId(x+neigh[0],y+neigh[1],z+neigh[2]);
      this.cells[cellIdX].needsUpdate=true;
    }
  }
  getVoxel(x,y,z){
    var voxel=this.computeVoxelOffset(x,y,z);
    var cellId=this.computeCellId(x,y,z);
    if(this.cells[cellId]!=undefined){
      var val=this.cells[cellId][this.parseVec(...voxel)];
      if(val!=undefined){
        return val;
      }else{
        return 0;
      }
    }else{
      return 0;
    }
  }
  updateCellGeometry(x,y,z){
    const {textureAtlas}=this;
    if(this.cells[this.parseVec(x,y,z)]==undefined || this.cells[this.parseVec(x,y,z)].needsUpdate){
      var mesh=this.cells_meshes[this.parseVec(x,y,z)];
      var geometry=this.generateCellGeometry(x,y,z);
      if(geometry!=null){
        if(mesh!=undefined){
          mesh.geometry=geometry;
        }else{
          var geometry=geometry;
          var mesh = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { map: textureAtlas, side: 0 } ) );
          scene.add(mesh)
          this.cells_meshes[this.parseVec(x,y,z)]=mesh;
        }
      }
      try{
        this.cells[this.parseVec(x,y,z)].needsUpdate=false;
      }catch(e){}
      
    }
  }
  generateCellGeometry(x,y,z){
    const {textureAtlas,cellSize}=this;
    var geometries=[];
    // Object.forEach(this.cells)
    for(var i=0;i<cellSize;i++){
      for(var j=0;j<cellSize;j++){
        for(var k=0;k<cellSize;k++){
          var voxelGeometries=this.generateVoxelGeometry(x*cellSize+i,y*cellSize+j,z*cellSize+k);
          // console.log(voxelGeometries)
          for(var l=0;l<voxelGeometries.length;l++){
            geometries.push(voxelGeometries[l]);
          }
        }
      }
    }
    // console.log(geometries)
    if(geometries.length!=0){
      var geometry = BufferGeometryUtils.mergeBufferGeometries( geometries );
      geometry.computeBoundingSphere();
    }else{
      var geometry=null;
    }
    return geometry;
  }
  generateVoxelGeometry(x,y,z){
    // console.log(x,y,z)
    var voxel=this.getVoxel(x,y,z);
    var matrix = new THREE.Matrix4();
    matrix.makeTranslation(x,y,z);
    if(voxel==1){
      var geometries=[];
      if(this.getVoxel(x-1,y,z)==0){
        var nxGeometry=this.generateFace("nx");
        geometries.push( nxGeometry.applyMatrix4( matrix ) )
      }
      if(this.getVoxel(x+1,y,z)==0){
        var pxGeometry=this.generateFace("px");
        geometries.push( pxGeometry.applyMatrix4( matrix ) )
      }
      if(this.getVoxel(x,y-1,z)==0){
        var nyGeometry=this.generateFace("ny");
        geometries.push( nyGeometry.applyMatrix4( matrix ) )
      }
      if(this.getVoxel(x,y+1,z)==0){
        var pyGeometry=this.generateFace("py");
        geometries.push( pyGeometry.applyMatrix4( matrix ) )
      }
      if(this.getVoxel(x,y,z-1)==0){
        var nzGeometry=this.generateFace("nz");
        geometries.push( nzGeometry.applyMatrix4( matrix ) )
      }
      if(this.getVoxel(x,y,z+1)==0){
        var pzGeometry=this.generateFace("pz");
        geometries.push( pzGeometry.applyMatrix4( matrix ) )
      } 
      return geometries;
    }else{
      return []
    }
  }
  generateFace(type){
    var geometry = new THREE.PlaneBufferGeometry(1, 1);
    if(type=="px"){
      geometry.rotateY( Math.PI / 2 );
      geometry.translate( 0.5, 0, 0 );
    }
    if(type=="nx"){
      geometry.rotateY( - Math.PI / 2 );
      geometry.translate( - 0.5, 0, 0 );
    }
    if(type=="py"){
      geometry.rotateX( - Math.PI / 2 );
      geometry.translate( 0, 0.5, 0 );
    }
    if(type=="ny"){
      geometry.rotateX( Math.PI / 2 );
      geometry.translate( 0, -0.5, 0 );
    }
    if(type=="pz"){
      geometry.translate( 0, 0, 0.5 );
    }
    if(type=="nz"){
      geometry.rotateY( Math.PI );
      geometry.translate( 0, 0, -0.5 );
    }
    var rx=Math.floor(Math.random()*4)
    var ry=15
    this.setUv(geometry,rx,ry,180)
    return geometry;
  }
  setUv(geometry,x,y,rotation=0){
    const {textureRows,textureCols}=this;
    var textureSizeX=1/textureRows;
    var textureSizeY=1/textureCols;
    if(rotation==0){
      geometry.attributes.uv.array[ 0 ] = textureSizeX*x;
      geometry.attributes.uv.array[ 1 ] = textureSizeY*y;

      geometry.attributes.uv.array[ 2 ] = textureSizeX+textureSizeX*x;
      geometry.attributes.uv.array[ 3 ] = 0+textureSizeY*y;

      geometry.attributes.uv.array[ 4 ] = 0+textureSizeX*x;
      geometry.attributes.uv.array[ 5 ] = textureSizeY+textureSizeY*y;

      geometry.attributes.uv.array[ 6 ] = textureSizeX+textureSizeX*x;
      geometry.attributes.uv.array[ 7 ] = textureSizeY+textureSizeY*y;
    }else if(rotation==180){
      geometry.attributes.uv.array[ 4 ] = textureSizeX*x;
      geometry.attributes.uv.array[ 5 ] = textureSizeY*y;

      geometry.attributes.uv.array[ 6 ] = textureSizeX+textureSizeX*x;
      geometry.attributes.uv.array[ 7 ] = 0+textureSizeY*y;

      geometry.attributes.uv.array[ 0 ] = 0+textureSizeX*x;
      geometry.attributes.uv.array[ 1 ] = textureSizeY+textureSizeY*y;

      geometry.attributes.uv.array[ 2 ] = textureSizeX+textureSizeX*x;
      geometry.attributes.uv.array[ 3 ] = textureSizeY+textureSizeY*y;
    }
  }
  
}
function precision(number){
  var precision = (number + "").split(".")[1].length;
  return precision;
}
var geometry = new THREE.BoxGeometry( 1, 1, 1 );
var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
var cube = new THREE.Mesh( geometry, material );
// cube.material.visible=false;
scene.add( cube );
function raycast(){
  raycaster.setFromCamera( mouse, camera );
  // calculate objects intersecting the picking ray
  var intersects = raycaster.intersectObjects( scene.children );
  var miniDist=-1
  var mini=null;
  for ( var i = 0; i < intersects.length; i++ ) {
    var ter=intersects[i]
    if(ter.object.uuid!=cube.uuid){
      if(miniDist==-1){
        miniDist=ter.distance
        mini=ter
      }else if(miniDist>ter.distance){
        miniDist=ter.distance
        mini=ter;
      }
    }
    
  }
  if(mini!=null){
    var xd=Math.round(mini.point.x)
    var yd=Math.round(mini.point.y)
    var zd=Math.round(mini.point.z)
    if(precision(mini.point.x)==1){
      console.log("x")
      var x1=Math.ceil(mini.point.x);
      var x2=Math.floor(mini.point.x);
      if(!world.getVoxel(x1,yd,zd)){
        cube.position.set(x1,yd,zd)
      }else if(!world.getVoxel(x2,yd,zd)){
        cube.position.set(x2,yd,zd)
      }
    }
    if(precision(mini.point.y)==1){
      console.log("y")
      var y1=Math.ceil(mini.point.y);
      var y2=Math.floor(mini.point.y);
      if(!world.getVoxel(xd,y1,zd)){
        cube.position.set(xd,y1,zd)
      }else if(!world.getVoxel(xd,y2,zd)){
        cube.position.set(xd,y2,zd)
      }
    }
    if(precision(mini.point.z)==1){
      console.log("z")
      var z1=Math.ceil(mini.point.z);
      var z2=Math.floor(mini.point.z);
      if(!world.getVoxel(xd,yd,z1)){
        cube.position.set(xd,yd,z1)
      }else if(!world.getVoxel(xd,yd,z2)){
        cube.position.set(xd,yd,z2)
      }
    }
    // console.log(mini.point)
  }
  
}

setInterval(function (){
  raycast()
})


var texture = new THREE.TextureLoader().load( 'atla.png' );
texture.magFilter = THREE.NearestFilter;
var world=new Terrain({
  textureAtlas:texture,
  textureRows:16,
  textureCols:16,
  cellSize:16,
})
var vari=50
for (let y = 0; y < vari; ++y) {
  for (let z = 0; z < vari*4; ++z) {
    for (let x = 0; x < vari; ++x) {
      const height = (Math.sin(x / vari * Math.PI * 2) + Math.sin(z / vari * Math.PI * 3)) * (vari / 6) + (vari / 2);
      if (y < height) {
          world.setVoxel(x, y, z, 1);
      }
    }
  }
}
// console.log(world.cells["0:0:0"])
for(var i=0;i<10;i++){
  for(var j=0;j<10;j++){
    for(var k=0;k<10;k++){
      world.updateCellGeometry(i,j,k);  
    }
  }
}



function animate() {
  render()
  requestAnimationFrame(animate)
}

function resizeRendererToDisplaySize(renderer) {
  const canvas = renderer.domElement;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  const needResize = canvas.width !== width || canvas.height !== height;
  if (needResize) {
    renderer.setSize(width, height, false);
  }
  return needResize;
}

function render() {
  if (resizeRendererToDisplaySize(renderer)) {
    const canvas = renderer.domElement;
    camera.aspect = canvas.clientWidth / canvas.clientHeight;
    camera.updateProjectionMatrix();
  }
  renderer.render(scene, camera);
}







    </script>
  </body>
</html>