<!DOCTYPE html>
<html>
  <head>

    <title>Web-Minecraft</title>

    <link rel="icon" href="assets/images/grass_block.png">

    <div css>
      <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.5.0/css/bootstrap.min.css">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.0/css/mdb.min.css">
      <link rel="stylesheet" href="css/main.css?11">
    </div>

    <div js>
      <script type="text/javascript" src="js/jq.js?1234"></script>
      <script type="text/javascript" src="js/popper.min.js?1234"></script>
      <script type="text/javascript" src="js/bootstrap.min.js?1234"></script>
      <script type="text/javascript" src="js/mdb.min.js?1234"></script>
      <script type="text/javascript" src="js/socket.io.js?1234"></script>
    </div>

  </head>
  <body>
    <canvas id="c"></canvas>
    <div class="initLoading">
      <img src="assets/images/loadingx.gif" class="loadingBar">
    </div>
    <div class="gui">
      <div class="inventoryBar"></div>
      <div class="gameMenu">
        <div class="row">
          <div class="col-4 pl-5 pt-4">
            Web-minecraft v.1.0
          </div>
          <div class="col-4 text-center p-3">
            <h3>Gra zatrzymana</h3>
            <button class="gameOn btn btn-dark w-100">
              Graj
            </button>
            <button class="btn btn-dark w-100" onclick="document.location.reload()">
             Restart
            </button>
          </div>
          <div class="col-4 p-3">
            Kontrolki
            <li>
              W: do przodu
            </li>
            <li>
              S: do tyłu
            </li>
            <li>
              A: w lewo
            </li>
            <li>
              D: w prawo
            </li>
            <li>
              Spacja: do góry
            </li>
            <li>
              Left Shift: do dołu
            </li>
            <li>
              Klawisze 1,2,3: Zmiana trzymającego itemu
            </li>

          </div>
        </div>
      </div>
      <div class="cross">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
          <line x1="15" y1="0" x2="15" y2="30" stroke="black" stroke-width="1" />
          <line x1="0" y1="15" x2="30" y2="15" stroke="black" stroke-width="1" />
        </svg>
      </div>
    </div>

    <script type="module">
import * as THREE from './module/build/three.module.js';
import {SkeletonUtils} from './module/jsm/utils/SkeletonUtils.js';
import {FBXLoader} from './module/jsm/loaders/FBXLoader.js';
import Stats from './module/jsm/libs/stats.module.js';
import {Tools} from './module/jsm/main/tools.js';
import {Terrain} from './module/jsm/main/Terrain.js';
import {TextureAtlasCreator} from './module/jsm/main/TextureAtlasCreator.js';
import {FirstPersonControls} from './module/jsm/main/FirstPersonControls.js';
import {InventoryBar} from './module/jsm/main/InventoryBar.js';


var canvas,renderer,scene,camera,stats,raycaster,
  gameState="menu",world,cube,FPC,socket,
  playerObject,textureAtlasMapping,materials,parameters;


init()
animate()


function init(){

  //basic setups
  {
    canvas = document.querySelector('#c');
    renderer = new THREE.WebGLRenderer({
      canvas,
      PixelRatio:window.devicePixelRatio
    });
    scene = new THREE.Scene();
    scene.background = new THREE.Color("lightblue");
    camera = new THREE.PerspectiveCamera(75, 2, 0.1, 1000);
    camera.rotation.order = "YXZ"
    camera.position.set(26, 26, 26)

    
    var ambientLight = new THREE.AmbientLight(0xcccccc);
    scene.add(ambientLight);
    var directionalLight = new THREE.DirectionalLight(0x333333, 2);
    directionalLight.position.set(1, 1, 0.5).normalize();
    scene.add(directionalLight);
    raycaster = new THREE.Raycaster();
    
    
    var textureLoader = new THREE.TextureLoader();
  }
  

  //Snowflakes
  {
    var geometry = new THREE.BufferGeometry();
    var vertices = [];
    materials=[]
    var sprite1 = textureLoader.load( 'assets/images/snowflakes/snowflake1.png' );
    var sprite2 = textureLoader.load( 'assets/images/snowflakes/snowflake2.png' );
    var sprite3 = textureLoader.load( 'assets/images/snowflakes/snowflake3.png' );
    var sprite4 = textureLoader.load( 'assets/images/snowflakes/snowflake4.png' );
    var sprite5 = textureLoader.load( 'assets/images/snowflakes/snowflake5.png' );
    for ( var i = 0; i < 100; i ++ ) {
      var x = Math.random() * 2000 - 1000;
      var y = Math.random() * 2000 - 1000;
      var z = Math.random() * 2000 - 1000;
      vertices.push( x, y, z );
    }
    geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
    parameters = [
      [[ 1.0, 0.2, 0.5 ], sprite2, 20 ],
      [[ 0.95, 0.1, 0.5 ], sprite3, 15 ],
      [[ 0.90, 0.05, 0.5 ], sprite1, 10 ],
      [[ 0.85, 0, 0.5 ], sprite5, 8 ],
      [[ 0.80, 0, 0.5 ], sprite4, 5 ]
    ];
    for ( var i = 0; i < parameters.length; i ++ ) {
      var color = parameters[ i ][ 0 ];
      var sprite = parameters[ i ][ 1 ];
      var size = parameters[ i ][ 2 ];
      materials[ i ] = new THREE.PointsMaterial( { size: size, map: sprite, blending: THREE.AdditiveBlending, depthTest: false, transparent: true } );
      materials[ i ].color.setHSL( color[ 0 ], color[ 1 ], color[ 2 ] );
      var particles = new THREE.Points( geometry, materials[ i ] );
      particles.rotation.x = Math.random() * 6;
      particles.rotation.y = Math.random() * 6;
      particles.rotation.z = Math.random() * 6;
      scene.add( particles );
    }
    for ( var i = 0; i < materials.length; i ++ ) {
      materials[ i ].map = parameters[ i ][ 1 ];
      materials[ i ].needsUpdate = true;
    }
  }


  //Load models
  {
    var manager = new THREE.LoadingManager();
    // manager.onStart = function ( url, itemsLoaded, itemsTotal ) {
    //   console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
    // };

    manager.onLoad = function ( ) {
      console.log( 'Loading complete!');
    };
    // manager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
    //   console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
    // };

    // manager.onError = function ( url ) {
    //   console.log( 'There was an error loading ' + url );
    // };


    var fbxl = new FBXLoader(manager);
    fbxl.load( 'assets/models/clouds/clouds.fbx', function ( object ) {
      object.scale.x=0.1
      object.scale.y=0.1
      object.scale.z=0.1
      object.position.y=100
      scene.add( object );
    } );
    fbxl.load( 'assets/models/ghast/ghast.fbx', function ( object ) {
      var texturex = new THREE.TextureLoader().load('assets/textures/ghast.png');
      texturex.magFilter = THREE.NearestFilter;
      object.children[0].children[0].scale.set(0.01,0.01,0.01)
      // object.children[1].position.set(25,25,25)
      object.children[1].material.map=texturex
      object.children[1].material.color=new THREE.Color( 0xffffff );
      // object.children[1].scale.set(0.5,0.5,0.5)
      scene.add(object)

      var ghast2=SkeletonUtils.clone(object);
      scene.add(ghast2)
      ghast2.position.set(3,0,0)
    });
    fbxl.load( 'assets/models/player/player.fbx', function ( object ) {
      var texturex = new THREE.TextureLoader().load('assets/textures/steve.png');
      // console.log("Creating new player:"+p)
      texturex.magFilter = THREE.NearestFilter;
      object.children[1].scale.set(1,1,1)
      object.children[1].position.set(25,25,25)
      object.children[0].material.map=texturex
      object.children[0].material.color=new THREE.Color( 0xffffff );
      object.children[1].scale.set(0.5,0.5,0.5)
      // scene.add(object)
      playerObject=object
    });
  }
  
  //World
  {
    var texture = new THREE.TextureLoader(manager).load('assets/textures/textureAtlas.png');
    texture.magFilter = THREE.NearestFilter;

    var worldMaterial=new THREE.MeshLambertMaterial({
      map: texture,
      side: 0
    })
    $.get("assets/textureMapping.json",function (textureMapping){
      world.textureAtlasMapping=textureMapping;
    })
    world = new Terrain({
      textureMaterial: worldMaterial,
      textureRows: 27,
      textureCols: 27,
      cellSize: 16,
      scene:scene
    })
    


    $.get(`assets/blocks.json?${Tools.uuidv4()}`,function (blocks){
      world.blocks=blocks
      var modelsNumber=0;
      var modelsLoaded=0;
      var modelsToLoad=[];
      var blocks=world.blocks
      Object.keys(blocks).forEach(function (p){
        if(!blocks[p].isBlock && p!=0){
          var modelPath=`assets/models/${blocks[p].model}`;
          modelsNumber++;
          modelsToLoad.push(blocks[p])
        }
      })
      // console.table(modelsToLoad)
      for(var i=0;i<modelsToLoad.length;i++){
        (function () {
          var block=modelsToLoad[i];
          fbxl.load( `assets/models/${block.model}`, function ( object ) {
            var geometry=object.children[0].geometry;
            if(block.name=="anvil"){
              geometry.rotateX(-Math.PI/2)
              geometry.translate(0,0.17,0)
              geometry.translate(0,-0.25,0)
            }
            if(block.name=="fire"){
              geometry.rotateX(-Math.PI/2)
              geometry.scale(0.5,0.5,0.5)
              // geometry.translate(0,0.25,0)
              // geometry.translate(0,-0.25,0)
            }
            world.saveModel(geometry,block.name)
            modelsLoaded++;
            if(modelsLoaded==modelsNumber){
              console.log("DONE! Models loaded!")
            }
          });
        })();
      }
    })
  }


  //animated Texture Atlas
  {
    var textureAtlasX = new Image;
    
    textureAtlasX.onload = function() {
      $.get("assets/textureMappingX.json",function (textureMappingX){
        var atlasCreator=new TextureAtlasCreator({
          textureX:textureAtlasX,
          textureMapping:textureMappingX
        })
        var savedTextures=[]
        for(var i=0;i<10;i++){
          var t=atlasCreator.gen(i).toDataURL();
          var tekstura=new THREE.TextureLoader(manager).load(t,function (textu){

            
            // worldMaterial.map=tekstura

            // worldMaterial.map.needsUpdate=true;
          });
          tekstura.magFilter = THREE.NearestFilter;
          savedTextures.push(tekstura)
        }
        var q;
        var tickq=0;

        setInterval(function (){
          try{
            q.remove()
          }catch(e){}
          tickq++;
          var tekst=savedTextures[tickq%9];
          worldMaterial.map=tekst

          worldMaterial.map.needsUpdate=true;
        },100)
        
      })
    }
    textureAtlasX.src = 'assets/textures/textureAtlasX.png';
  }
  

  //Socket io
  {
    socket=io.connect("http://localhost:35565");
    socket.on("connect",()=>{
      console.log("Połączono z serverem!")
    })
    socket.on("blockUpdate",function (block){
      world.setVoxel(...block)
    })
    var playersx={}
    socket.on("playerUpdate",function (players){
      var sockets={};
      Object.keys(players).forEach(function (p){
        sockets[p]=true;
        if(playersx[p]==undefined && p!=socket.id){
          playersx[p]=SkeletonUtils.clone(playerObject);
          scene.add(playersx[p])
        }
        try{
          playersx[p].children[1].position.set(players[p].x,players[p].y-0.5,players[p].z)
          playersx[p].children[1].children[0].children[0].children[0].children[2].rotation.x=players[p].xyaw;
          playersx[p].children[1].children[0].rotation.z=players[p].zyaw
        }catch(e){}
      })
      Object.keys(playersx).forEach(function (p){
        if(sockets[p]==undefined){
          scene.remove(playersx[p]);
          delete playersx[p]
        }
      })
    })
    socket.on("firstLoad",function (v){
      console.log("Otrzymano pakiet świata!")
      // console.log(v)
      world.replaceWorld(v,world)
      $(".initLoading").css("display","none")
      stats = new Stats();
      stats.showPanel(0);
      document.body.appendChild(stats.dom);
       // 0: fps, 1: ms, 2: mb, 3+: custom
    })
  }
  

  //Inventory Bar
  {
    var inv_bar = new InventoryBar({
      boxSize: 60,
      boxes: 9,
      padding: 4,
      div: ".inventoryBar",
      activeBox: 1
    })
    inv_bar.setBox(1,"assets/images/grass_block.png")
    inv_bar.setBox(2,"assets/images/stone.png")
    inv_bar.setBox(3,"assets/images/oak_planks.png")
    inv_bar.setBox(4,"assets/images/smoker.gif")
    inv_bar.setBox(5,"assets/images/anvil.png")
    inv_bar.setBox(6,"assets/images/brick.png")
    inv_bar.setBox(7,"assets/images/furnace.png")
    inv_bar.setBox(8,"assets/images/bookshelf.png")
    inv_bar.setBox(9,"assets/images/tnt.png")
    inv_bar.setFocusOnly(1)
    $(window).on('wheel', function (event) {
      if (event.originalEvent.deltaY < 0) {
        inv_bar.moveBoxPlus()
      } else {
        inv_bar.moveBoxMinus()
      }
    })
  }


  //First Person Controls
  {
    FPC = new FirstPersonControls({
      canvas: document.getElementById("c"),
      camera,
      micromove: 0.3
    })
    function updatePosition(e) {
      FPC.camera.rotation.x -= FPC.degtorad(e.movementY / 10)
      FPC.camera.rotation.y -= FPC.degtorad(e.movementX / 10)
      if (FPC.radtodeg(FPC.camera.rotation.x) < -90) {
        FPC.camera.rotation.x = FPC.degtorad(-90)
      }
      if (FPC.radtodeg(FPC.camera.rotation.x) > 90) {
        FPC.camera.rotation.x = FPC.degtorad(90)
      }
    }
    function lockChangeAlert() {
      if (document.pointerLockElement === canvas || document.mozPointerLockElement === canvas) {
        document.addEventListener("mousemove", updatePosition, false);
        $(".gameMenu").css("display", "none")
        gameState="game"
      } else {
        document.removeEventListener("mousemove", updatePosition, false);
        $(".gameMenu").css("display", "block")
        gameState="menu"
      }
    }
    document.addEventListener('pointerlockchange', lockChangeAlert, false);
    document.addEventListener('mozpointerlockchange', lockChangeAlert, false);
    $(document).keydown(function (z) {
      FPC.keys[z.keyCode] = true;
      inv_bar.directBoxChange(z)
    })
    $(document).keyup(function (z) {
      delete FPC.keys[z.keyCode];
    })
    $(".gameOn").click(function () {
      FPC.lockPointer()
    })
  }
  

  //Raycast cube
  {
    var geometry = new THREE.BoxGeometry(1, 1, 1);
    var material = new THREE.MeshBasicMaterial({
      color: 0x00ff00
    });
    var edges = new THREE.EdgesGeometry(geometry);
    cube = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({
      color: 0x000000,
      linewidth: 0.5
    }));
    scene.add(cube);
  }

  
  $(document).mousedown(function (e) {
    if (gameState=="game") {
      const start = new THREE.Vector3().setFromMatrixPosition(camera.matrixWorld);
      const end = new THREE.Vector3().set(0,0, 1).unproject(camera);
      const intersection = world.intersectsRay(start, end);
      if (e.which == 1) {
        var voxelId=0;
      } else {
        var voxelId=inv_bar.activeBox;
      }
      if(intersection){
        const pos = intersection.position.map((v, ndx) => {
          return v + intersection.normal[ndx] * (voxelId > 0 ? 0.5 : -0.5);
        });
        // world.setVoxel(...pos, voxelId);
        socket.emit("blockUpdate",[...pos,voxelId])
      }
    }
  })
}






function animate() {
  try{
    stats.begin();
  }catch(e){}
  
  render()
  try{
    stats.end();
  }catch(e){}
  
  requestAnimationFrame(animate)
}


function render() {
  var time = Date.now() * 0.00005;
  for ( var i = 0; i < scene.children.length; i ++ ) {
    var object = scene.children[ i ];
    if ( object instanceof THREE.Points ) {
      object.rotation.y = time * ( i < 4 ? i + 1 : - ( i + 1 ) );
    }
  }
  for ( var i = 0; i < materials.length; i ++ ) {
    var color = parameters[ i ][ 0 ];
    var h = ( 360 * ( color[ 0 ] + time ) % 360 ) / 360;
    materials[ i ].color.setHSL( h, color[ 1 ], color[ 2 ] );
  }


  const canvas = renderer.domElement;
  const width = canvas.clientWidth;
  const height = canvas.clientHeight;
  const needResize = canvas.width !== width || canvas.height !== height;
  if (needResize) {
    renderer.setSize(width, height, false);
    const canvas = renderer.domElement;
    camera.aspect = canvas.clientWidth / canvas.clientHeight;
    camera.updateProjectionMatrix();
  }
    
  if (gameState=="game") {
    socket.emit("playerUpdate",{
      x:camera.position.x,
      y:camera.position.y,
      z:camera.position.z,
      xyaw:-camera.rotation.x,
      zyaw:camera.rotation.y+Math.PI
    })
    FPC.camMicroMove()

  }
  renderer.render(scene, camera);
  world.updateCells(world)
  

  const start = new THREE.Vector3().setFromMatrixPosition(camera.matrixWorld);
  const end = new THREE.Vector3().set(0,0, 1).unproject(camera);
  const intersection = world.intersectsRay(start, end);
  if(intersection){
    const pos = intersection.position.map((v, ndx) => {
      return v + intersection.normal[ndx] * -0.5;
    });
    pos[0]=Math.floor(pos[0])
    pos[1]=Math.floor(pos[1])
    pos[2]=Math.floor(pos[2])
    cube.position.set(...pos)
    // console.log(pos)
    cube.visible=true;
  }else{
    cube.visible=false;
  }

  
}
    </script>
  </body>
</html>