// Generated by CoffeeScript 2.5.1
var World;

import pChunk from 'prismarine-chunk';

import vec3 from 'vec3';

import ndarray from "ndarray";

World = class World {
  constructor(noa) {
    var _this, brownish, dirtID, grassID, greenish, textureURL;
    _this = this;
    this.noa = noa;
    this.Chunk = pChunk("1.16.3");
    this.chunkStorage = {};
    this.chunkNeedsUpdate = {};
    this.noa.world.on('worldDataNeeded', function(id, data, x, y, z) {
      var ix, iy, iz, l, m, n, noaChunk;
      noaChunk = _this.chunkStorage[id];
      for (ix = l = 0; l <= 15; ix = ++l) {
        for (iy = m = 0; m <= 15; iy = ++m) {
          for (iz = n = 0; n <= 15; iz = ++n) {
            data.set(ix, iy, iz, noaChunk.get(15 - ix, iy, iz));
          }
        }
      }
      _this.noa.world.setChunkData(id, data);
    });
    this.noa.world.on("playerEnteredChunk", function(ci, cj, ck) {
      var add, dist, i, j, k, l, m, n, ref, ref1, ref2, ref3, ref4, ref5;
      add = _this.noa.world.chunkAddDistance;
      for (i = l = ref = ci - add, ref1 = ci + add; (ref <= ref1 ? l <= ref1 : l >= ref1); i = ref <= ref1 ? ++l : --l) {
        for (j = m = ref2 = cj - add, ref3 = cj + add; (ref2 <= ref3 ? m <= ref3 : m >= ref3); j = ref2 <= ref3 ? ++m : --m) {
          for (k = n = ref4 = ck - add, ref5 = ck + add; (ref4 <= ref5 ? n <= ref5 : n >= ref5); k = ref4 <= ref5 ? ++n : --n) {
            if (!_this.noa.world._chunksKnown.includes(i, j, k)) {
              if (_this.chunkStorage[`${i}|${j}|${k}|default`] !== void 0) {
                _this.noa.world.manuallyLoadChunk(i * 16, j * 16, k * 16);
              }
            }
          }
        }
      }
      dist = _this.noa.world.chunkRemoveDistance;
      _this.noa.world._chunksKnown.forEach(function(loc) {
        var di, dj, dk;
        if (_this.noa.world._chunksToRemove.includes(loc[0], loc[1], loc[2])) {
          return;
        }
        di = loc[0] - ci;
        dj = loc[1] - cj;
        dk = loc[2] - ck;
        if (dist <= Math.abs(di) || dist <= Math.abs(dj) || dist <= Math.abs(dk)) {
          _this.noa.world.manuallyUnloadChunk(loc[0] * 16, loc[1] * 16, loc[2] * 16);
        }
      });
    });
    textureURL = null;
    brownish = [0.45, 0.36, 0.22];
    greenish = [0.1, 0.8, 0.2];
    this.noa.registry.registerMaterial('dirt', brownish, textureURL);
    this.noa.registry.registerMaterial('grass', greenish, textureURL);
    dirtID = this.noa.registry.registerBlock(1, {
      material: 'dirt'
    });
    grassID = this.noa.registry.registerBlock(2, {
      material: 'grass'
    });
    return;
  }

  loadChunk(chunk, x, z) {
    var add, bid, ch, ci, cj, ck, ix, iy, iz, l, m, n, noaChunk, o, pos, ref, y;
    console.log(x, z);
    x = -x - 1;
    ch = this.Chunk.fromJson(chunk);
    for (y = l = 0, ref = ch.sections.length - 1; (0 <= ref ? l <= ref : l >= ref); y = 0 <= ref ? ++l : --l) {
      noaChunk = new ndarray(new Uint16Array(16 * 16 * 16), [16, 16, 16]);
      if (ch.sections[y] !== null) {
        for (ix = m = 0; m <= 15; ix = ++m) {
          for (iy = n = 0; n <= 15; iy = ++n) {
            for (iz = o = 0; o <= 15; iz = ++o) {
              bid = ch.sections[y].getBlock(vec3(ix, iy, iz));
              if (bid === 0) {
                noaChunk.set(ix, iy, iz, 0);
              } else {
                noaChunk.set(ix, iy, iz, 1);
              }
            }
          }
        }
      }
      this.chunkStorage[`${x}|${y}|${z}|default`] = noaChunk;
      add = this.noa.world.chunkAddDistance;
      pos = this.noa.ents.getPosition(this.noa.playerEntity);
      ci = Math.ceil(pos[0] / 16);
      cj = Math.ceil(pos[1] / 16);
      ck = Math.ceil(pos[2] / 16);
      if (x > ci - add && x < ci + add && y > cj - add && y < cj + add && z > ck - add && z < ck + add) {
        this.noa.world.manuallyLoadChunk(x * 16, y * 16, z * 16);
      }
    }
  }

};

export {
  World
};
