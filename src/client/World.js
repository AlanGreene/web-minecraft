// Generated by CoffeeScript 2.5.1
var World;

import pChunk from 'prismarine-chunk';

import vec3 from 'vec3';

import ndarray from "ndarray";

World = class World {
  constructor(noa) {
    var _this, brownish;
    _this = this;
    this.noa = noa;
    this.Chunk = pChunk("1.16.3");
    this.chunkStorage = {};
    this.chunkNeedsUpdate = {};
    this.noa.world.on('worldDataNeeded', function(id, data, x, y, z) {
      var noaChunk, noaNewChunk;
      noaChunk = _this.chunkStorage[id];
      noaNewChunk = new ndarray(noaChunk.data, noaChunk.shape);
      _this.noa.world.setChunkData(id, noaNewChunk);
    });
    this.noa.world.on("playerEnteredChunk", function(ci, cj, ck) {
      _this.loadChunksAroundPlayer(ci, cj, ck);
      _this.unloadChunksAroundPlayer(ci, cj, ck);
    });
    brownish = [0.45, 0.36, 0.22];
    this.noa.registry.registerMaterial('dirt', brownish, "dirt.png");
    this.noa.registry.registerMaterial('water', [0.5, 0.5, 0.8, 0.7], null);
    this.noa.registry.registerMaterial('lava', [158 / 255, 83 / 255, 13 / 255, 0.99], null);
    this.noa.registry.registerBlock(1, {
      material: 'dirt'
    });
    this.noa.registry.registerBlock(2, {
      material: 'grass'
    });
    this.noa.registry.registerBlock(3, {
      material: 'water',
      fluid: true
    });
    this.noa.registry.registerBlock(4, {
      material: 'lava',
      fluid: true
    });
    return;
  }

  loadChunksAroundPlayer(ci, cj, ck) {
    var add, i, j, k, l, m, n, ref, ref1, ref2, ref3, ref4, ref5;
    add = this.noa.world.chunkAddDistance;
    for (i = l = ref = ci - add, ref1 = ci + add; (ref <= ref1 ? l <= ref1 : l >= ref1); i = ref <= ref1 ? ++l : --l) {
      for (j = m = ref2 = cj - add, ref3 = cj + add; (ref2 <= ref3 ? m <= ref3 : m >= ref3); j = ref2 <= ref3 ? ++m : --m) {
        for (k = n = ref4 = ck - add, ref5 = ck + add; (ref4 <= ref5 ? n <= ref5 : n >= ref5); k = ref4 <= ref5 ? ++n : --n) {
          if (!this.noa.world._chunksKnown.includes(i, j, k)) {
            if (this.chunkStorage[`${i}|${j}|${k}|default`] !== void 0) {
              this.noa.world.manuallyLoadChunk(i * 16, j * 16, k * 16);
            }
          }
        }
      }
    }
  }

  unloadChunksAroundPlayer(ci, cj, ck) {
    var _this, dist;
    _this = this;
    dist = this.noa.world.chunkRemoveDistance;
    this.noa.world._chunksKnown.forEach(function(loc) {
      var di, dj, dk;
      if (_this.noa.world._chunksToRemove.includes(loc[0], loc[1], loc[2])) {
        return;
      }
      di = loc[0] - ci;
      dj = loc[1] - cj;
      dk = loc[2] - ck;
      if (dist <= Math.abs(di) || dist <= Math.abs(dj) || dist <= Math.abs(dk)) {
        _this.noa.world.manuallyUnloadChunk(loc[0] * 16, loc[1] * 16, loc[2] * 16);
      }
    });
  }

  loadChunk(chunk, x, z) {
    var add, b, ch, ci, cj, ck, ix, iy, iz, l, m, n, noaChunk, o, pos, ref, y;
    x = -x - 1;
    ch = this.Chunk.fromJson(chunk);
    for (y = l = 0, ref = ch.sections.length - 1; (0 <= ref ? l <= ref : l >= ref); y = 0 <= ref ? ++l : --l) {
      noaChunk = new ndarray(new Uint16Array(16 * 16 * 16), [16, 16, 16]);
      if (ch.sections[y] !== null) {
        for (ix = m = 0; m <= 15; ix = ++m) {
          for (iy = n = 0; n <= 15; iy = ++n) {
            for (iz = o = 0; o <= 15; iz = ++o) {
              b = ch.getBlock(vec3(ix, iy + y * 16, iz));
              if (b.name === "air" || b.name === "cave_air" || b.name === "void_air") {
                noaChunk.set(15 - ix, iy, iz, 0);
              } else if (b.name === "water") {
                noaChunk.set(15 - ix, iy, iz, 3);
              } else if (b.name === "lava") {
                noaChunk.set(15 - ix, iy, iz, 4);
              } else {
                noaChunk.set(15 - ix, iy, iz, 1);
              }
            }
          }
        }
      }
      this.chunkStorage[`${x}|${y}|${z}|default`] = noaChunk;
      add = this.noa.world.chunkAddDistance;
      pos = this.noa.ents.getPosition(this.noa.playerEntity);
      ci = Math.ceil(pos[0] / 16);
      cj = Math.ceil(pos[1] / 16);
      ck = Math.ceil(pos[2] / 16);
      if (x > ci - add && x < ci + add && y > cj - add && y < cj + add && z > ck - add && z < ck + add) {
        this.noa.world.manuallyLoadChunk(x * 16, y * 16, z * 16);
      }
    }
  }

};

export {
  World
};
