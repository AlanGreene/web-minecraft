// Generated by CoffeeScript 2.5.1
var Terrain;

import * as THREE from './../module/build/three.module.js';

import {
  CellTerrain
} from './CellTerrain.js';

Terrain = class Terrain {
  constructor(options) {
    var _this;
    _this = this;
    this.cellMesh = {};
    this.cellNeedsUpdate = {};
    this.models = {};
    this.cellSize = options.cellSize;
    this.material = options.material;
    this.camera = options.camera;
    this.scene = options.scene;
    this.toxelSize = options.toxelSize;
    this.al = options.al;
    this.cellTerrain = new CellTerrain({
      cellSize: this.cellSize
    });
    this.neighbours = [[-1, 0, 0], [1, 0, 0], [0, -1, 0], [0, 1, 0], [0, 0, -1], [0, 0, 1]];
    this.worker = new Worker("./module/TerrainWorker.js", {
      type: 'module'
    });
    this.worker.onmessage = function(message) {
      return _this.updateCell(message.data);
    };
    this.worker.postMessage({
      type: 'init',
      data: {
        models: {
          anvil: {...this.al.get("anvil").children[0].geometry.attributes}
        },
        blocks: this.al.get("blocks"),
        blocksMapping: this.al.get("blocksMapping"),
        toxelSize: this.toxelSize,
        cellSize: this.cellSize
      }
    });
    this.neighbours = [[-1, 0, 0], [1, 0, 0], [0, -1, 0], [0, 1, 0], [0, 0, -1], [0, 0, 1]];
  }

  setBlock(voxelX, voxelY, voxelZ, value) {
    var cellId, i, len1, nei, neiCellId, ref;
    voxelX = parseInt(voxelX);
    voxelY = parseInt(voxelY);
    voxelZ = parseInt(voxelZ);
    if ((this.cellTerrain.getVoxel(voxelX, voxelY, voxelZ)) !== value) {
      this._setVoxel(voxelX, voxelY, voxelZ, value);
      this.cellTerrain.setVoxel(voxelX, voxelY, voxelZ, value);
      cellId = this.cellTerrain.vec3(...this.cellTerrain.computeCellForVoxel(voxelX, voxelY, voxelZ));
      this.cellNeedsUpdate[cellId] = true;
      ref = this.neighbours;
      for (i = 0, len1 = ref.length; i < len1; i++) {
        nei = ref[i];
        neiCellId = this.cellTerrain.vec3(...this.cellTerrain.computeCellForVoxel(voxelX + nei[0], voxelY + nei[1], voxelZ + nei[2]));
        this.cellNeedsUpdate[neiCellId] = true;
      }
    }
  }

  getBlock(voxelX, voxelY, voxelZ) {
    return this.cellTerrain.getVoxel(voxelX, voxelY, voxelZ);
  }

  updateCells() {
    var _this;
    _this = this;
    Object.keys(this.cellNeedsUpdate).forEach(function(id) {
      if (_this.cellNeedsUpdate[id]) {
        _this._genCellGeo(...id.split(":"));
        return delete _this.cellNeedsUpdate[id];
      }
    });
  }

  updateCell(data) {
    var cell, cellId, geometry, mesh;
    cellId = this.cellTerrain.vec3(...data.info);
    cell = data.cell;
    mesh = this.cellMesh[cellId];
    geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(cell.positions), 3));
    geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(cell.normals), 3));
    geometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(cell.uvs), 2));
    if (mesh === void 0) {
      this.cellMesh[cellId] = new THREE.Mesh(geometry, this.material);
      this.scene.add(this.cellMesh[cellId]);
    } else {
      this.cellMesh[cellId].geometry = geometry;
    }
  }

  intersectsRay(start, end) {
    var dx, dy, dz, ix, iy, iz, len, lenSq, stepX, stepY, stepZ, steppedIndex, t, txDelta, txMax, tyDelta, tyMax, tzDelta, tzMax, voxel, xDist, yDist, zDist;
    start.x += 0.5;
    start.y += 0.5;
    start.z += 0.5;
    end.x += 0.5;
    end.y += 0.5;
    end.z += 0.5;
    dx = end.x - start.x;
    dy = end.y - start.y;
    dz = end.z - start.z;
    lenSq = dx * dx + dy * dy + dz * dz;
    len = Math.sqrt(lenSq);
    dx /= len;
    dy /= len;
    dz /= len;
    t = 0.0;
    ix = Math.floor(start.x);
    iy = Math.floor(start.y);
    iz = Math.floor(start.z);
    stepX = dx > 0 ? 1 : -1;
    stepY = dy > 0 ? 1 : -1;
    stepZ = dz > 0 ? 1 : -1;
    txDelta = Math.abs(1 / dx);
    tyDelta = Math.abs(1 / dy);
    tzDelta = Math.abs(1 / dz);
    xDist = stepX > 0 ? ix + 1 - start.x : start.x - ix;
    yDist = stepY > 0 ? iy + 1 - start.y : start.y - iy;
    zDist = stepZ > 0 ? iz + 1 - start.z : start.z - iz;
    txMax = txDelta < 2e308 ? txDelta * xDist : 2e308;
    tyMax = tyDelta < 2e308 ? tyDelta * yDist : 2e308;
    tzMax = tzDelta < 2e308 ? tzDelta * zDist : 2e308;
    steppedIndex = -1;
    while (t <= len) {
      voxel = this.getBlock(ix, iy, iz);
      if (voxel) {
        return {
          position: [start.x + t * dx, start.y + t * dy, start.z + t * dz],
          normal: [steppedIndex === 0 ? -stepX : 0, steppedIndex === 1 ? -stepY : 0, steppedIndex === 2 ? -stepZ : 0],
          voxel
        };
      }
      if (txMax < tyMax) {
        if (txMax < tzMax) {
          ix += stepX;
          t = txMax;
          txMax += txDelta;
          steppedIndex = 0;
        } else {
          iz += stepZ;
          t = tzMax;
          tzMax += tzDelta;
          steppedIndex = 2;
        }
      } else {
        if (tyMax < tzMax) {
          iy += stepY;
          t = tyMax;
          tyMax += tyDelta;
          steppedIndex = 1;
        } else {
          iz += stepZ;
          t = tzMax;
          tzMax += tzDelta;
          steppedIndex = 2;
        }
      }
    }
    return null;
  }

  replaceWorld(voxels) {
    var _this;
    _this = this;
    return Object.keys(voxels).forEach(function(id) {
      if (voxels[id] !== _this.getBlock(...id.split(":"))) {
        return _this.setBlock(...id.split(":"), voxels[id]);
      }
    });
  }

  getRayBlock() {
    var end, intersection, posBreak, posPlace, start;
    start = new THREE.Vector3().setFromMatrixPosition(this.camera.matrixWorld);
    end = new THREE.Vector3().set(0, 0, 1).unproject(this.camera);
    intersection = this.intersectsRay(start, end);
    if (intersection) {
      posPlace = intersection.position.map(function(v, ndx) {
        return v + intersection.normal[ndx] * 0.5;
      });
      posBreak = intersection.position.map(function(v, ndx) {
        return v + intersection.normal[ndx] * -0.5;
      });
      return {posPlace, posBreak};
    } else {
      return false;
    }
  }

  _setVoxel(voxelX, voxelY, voxelZ, value) {
    return this.worker.postMessage({
      type: "setVoxel",
      data: [voxelX, voxelY, voxelZ, value]
    });
  }

  _genCellGeo(cellX, cellY, cellZ) {
    cellX = parseInt(cellX);
    cellY = parseInt(cellY);
    cellZ = parseInt(cellZ);
    return this.worker.postMessage({
      type: "genCellGeo",
      data: [cellX, cellY, cellZ]
    });
  }

};

export {
  Terrain
};
