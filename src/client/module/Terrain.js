// Generated by CoffeeScript 2.5.1
var Terrain,
  modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

import * as THREE from './../module/build/three.module.js';

import {
  CellTerrain
} from './CellTerrain.js';

Terrain = class Terrain {
  constructor(options) {
    this.cellSize = options.cellSize;
    this.cellTerrain = new CellTerrain({
      cellSize: this.cellSize
    });
    // @cellTerrain.getBuffer(0,0,0)
    this.cellsData = {};
    this.blocks = options.blocks;
    this.blocksMapping = options.blocksMapping;
    this.material = options.material;
    this.cells = {};
    this.models = {};
    this.camera = options.camera;
    this.scene = options.scene;
    this.toxelSize = options.toxelSize;
    this.neighbours = [[-1, 0, 0], [1, 0, 0], [0, -1, 0], [0, 1, 0], [0, 0, -1], [0, 0, 1]];
    this.worker = options.worker;
  }

  computeVoxelOffset(voxelX, voxelY, voxelZ) {
    var x, y, z;
    x = modulo(voxelX, this.cellSize) | 0;
    y = modulo(voxelY, this.cellSize) | 0;
    z = modulo(voxelZ, this.cellSize) | 0;
    return [x, y, z];
  }

  computeCellForVoxel(voxelX, voxelY, voxelZ) {
    var cellX, cellY, cellZ;
    cellX = Math.floor(voxelX / this.cellSize);
    cellY = Math.floor(voxelY / this.cellSize);
    cellZ = Math.floor(voxelZ / this.cellSize);
    return [cellX, cellY, cellZ];
  }

  vec3(x, y, z) {
    x = parseInt(x);
    y = parseInt(y);
    z = parseInt(z);
    return `${x}:${y}:${z}`;
  }

  setVoxel(voxelX, voxelY, voxelZ, value) {
    var cell, cellId, i, len1, nei, neiCellId, prevVox, ref, voff;
    this.worker.setVoxel(voxelX, voxelY, voxelZ, value);
    voff = this.computeVoxelOffset(voxelX, voxelY, voxelZ);
    cell = this.computeCellForVoxel(voxelX, voxelY, voxelZ);
    cellId = this.vec3(...cell);
    if (this.cellsData[cellId] === void 0) {
      this.cellsData[cellId] = {
        [this.vec3(...voff)]: value
      };
    } else {
      prevVox = this.cellsData[cellId][this.vec3(...voff)];
      if (prevVox !== value) {
        this.cellsData[cellId][this.vec3(...voff)] = value;
        this.cellsData[cellId].needsUpdate = true;
        ref = this.neighbours;
        for (i = 0, len1 = ref.length; i < len1; i++) {
          nei = ref[i];
          neiCellId = this.vec3(...this.computeCellForVoxel(voxelX + nei[0], voxelY + nei[1], voxelZ + nei[2]));
          try {
            this.cellsData[neiCellId].needsUpdate = true;
          } catch (error) {}
        }
      }
    }
    this.cellsData[cellId].needsUpdate = true;
  }

  getVoxel(voxelX, voxelY, voxelZ) {
    var cell, cellId, voff, voxId, voxel;
    cell = this.computeCellForVoxel(voxelX, voxelY, voxelZ);
    cellId = this.vec3(...cell);
    voff = this.computeVoxelOffset(voxelX, voxelY, voxelZ);
    voxId = this.vec3(...voff);
    if (this.cellsData[cellId] !== void 0) {
      voxel = this.cellsData[cellId][voxId];
      if (voxel !== void 0) {
        return voxel;
      }
    }
    return 0;
  }

  updateCells() {
    var _this;
    _this = this;
    Object.keys(this.cellsData).forEach(function(id) {
      if (_this.cellsData[id].needsUpdate) {
        _this.worker.genCellGeo(...id.split(":"));
      }
    });
  }

  updateCell(data) {
    var cell, cellId, geometry, mesh;
    // console.warn "SENDING  cell: #{data.info}" 
    cellId = this.vec3(...data.info);
    cell = data.cell;
    if (this.cellsData[cellId] !== void 0) {
      if (this.cellsData[cellId].needsUpdate) {
        mesh = this.cells[cellId];
        geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(cell.positions), 3));
        geometry.setAttribute('normal', new THREE.BufferAttribute(new Float32Array(cell.normals), 3));
        geometry.setAttribute('uv', new THREE.BufferAttribute(new Float32Array(cell.uvs), 2));
        if (mesh === void 0) {
          this.cells[cellId] = new THREE.Mesh(geometry, this.material);
          this.scene.add(this.cells[cellId]);
        } else {
          this.cells[cellId].geometry = geometry;
        }
        this.cellsData[cellId].needsUpdate = false;
      }
    }
  }

  intersectsRay(start, end) {
    var dx, dy, dz, ix, iy, iz, len, lenSq, stepX, stepY, stepZ, steppedIndex, t, txDelta, txMax, tyDelta, tyMax, tzDelta, tzMax, voxel, xDist, yDist, zDist;
    start.x += 0.5;
    start.y += 0.5;
    start.z += 0.5;
    end.x += 0.5;
    end.y += 0.5;
    end.z += 0.5;
    dx = end.x - start.x;
    dy = end.y - start.y;
    dz = end.z - start.z;
    lenSq = dx * dx + dy * dy + dz * dz;
    len = Math.sqrt(lenSq);
    dx /= len;
    dy /= len;
    dz /= len;
    t = 0.0;
    ix = Math.floor(start.x);
    iy = Math.floor(start.y);
    iz = Math.floor(start.z);
    stepX = dx > 0 ? 1 : -1;
    stepY = dy > 0 ? 1 : -1;
    stepZ = dz > 0 ? 1 : -1;
    txDelta = Math.abs(1 / dx);
    tyDelta = Math.abs(1 / dy);
    tzDelta = Math.abs(1 / dz);
    xDist = stepX > 0 ? ix + 1 - start.x : start.x - ix;
    yDist = stepY > 0 ? iy + 1 - start.y : start.y - iy;
    zDist = stepZ > 0 ? iz + 1 - start.z : start.z - iz;
    txMax = txDelta < 2e308 ? txDelta * xDist : 2e308;
    tyMax = tyDelta < 2e308 ? tyDelta * yDist : 2e308;
    tzMax = tzDelta < 2e308 ? tzDelta * zDist : 2e308;
    steppedIndex = -1;
    while (t <= len) {
      voxel = this.getVoxel(ix, iy, iz);
      if (voxel) {
        return {
          position: [start.x + t * dx, start.y + t * dy, start.z + t * dz],
          normal: [steppedIndex === 0 ? -stepX : 0, steppedIndex === 1 ? -stepY : 0, steppedIndex === 2 ? -stepZ : 0],
          voxel
        };
      }
      if (txMax < tyMax) {
        if (txMax < tzMax) {
          ix += stepX;
          t = txMax;
          txMax += txDelta;
          steppedIndex = 0;
        } else {
          iz += stepZ;
          t = tzMax;
          tzMax += tzDelta;
          steppedIndex = 2;
        }
      } else {
        if (tyMax < tzMax) {
          iy += stepY;
          t = tyMax;
          tyMax += tyDelta;
          steppedIndex = 1;
        } else {
          iz += stepZ;
          t = tzMax;
          tzMax += tzDelta;
          steppedIndex = 2;
        }
      }
    }
    return null;
  }

  replaceWorld(voxels) {
    var _this;
    _this = this;
    return Object.keys(voxels).forEach(function(id) {
      if (voxels[id] !== _this.getVoxel(...id.split(":"))) {
        return _this.setVoxel(...id.split(":"), voxels[id]);
      }
    });
  }

  getRayBlock() {
    var end, intersection, posBreak, posPlace, start;
    start = new THREE.Vector3().setFromMatrixPosition(this.camera.matrixWorld);
    end = new THREE.Vector3().set(0, 0, 1).unproject(this.camera);
    intersection = this.intersectsRay(start, end);
    if (intersection) {
      posPlace = intersection.position.map(function(v, ndx) {
        return v + intersection.normal[ndx] * 0.5;
      });
      posBreak = intersection.position.map(function(v, ndx) {
        return v + intersection.normal[ndx] * -0.5;
      });
      return {posPlace, posBreak};
    } else {
      return false;
    }
  }

};

export {
  Terrain
};
