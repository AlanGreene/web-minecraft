// Generated by CoffeeScript 2.5.1
var State, TerrainManager, handlers, terrain, time;

import {
  CellTerrain
} from './CellTerrain.js';

console.log("CHUNK WORKER STARTED!");

TerrainManager = class TerrainManager {
  constructor(options) {
    this.cellSize = options.cellSize;
    this.cellTerrain = new CellTerrain({
      cellSize: this.cellSize
    });
    this.toxelSize = options.toxelSize;
    this.q = 1 / this.toxelSize;
    this.blocksMapping = options.blocksMapping;
  }

  genBlockFace(type, block, pos) {
    var li, sh, toxX, toxY, uv, x1, x2, y1, y2;
    if (block.name === "water") {
      toxX = this.blocksMapping["water_flow"]["x"];
      toxY = this.blocksMapping["water_flow"]["y"];
    } else if (this.blocksMapping[block.name]) {
      toxX = this.blocksMapping[block.name]["x"];
      toxY = this.blocksMapping[block.name]["y"];
    } else {
      toxX = this.blocksMapping["debug"]["x"];
      toxY = 28 - this.blocksMapping["debug"]["y"];
    }
    li = [255, 255, 255];
    sh = [0, 0, 0];
    toxX -= 1;
    toxY -= 1;
    x1 = this.q * toxX;
    y1 = 1 - this.q * toxY - this.q;
    x2 = this.q * toxX + this.q;
    y2 = 1 - this.q * toxY;
    uv = [[x1, y1], [x1, y2], [x2, y1], [x2, y2]];
    switch (type) {
      case "pz":
        return {
          pos: [-0.5 + pos[0], -0.5 + pos[1], 0.5 + pos[2], 0.5 + pos[0], -0.5 + pos[1], 0.5 + pos[2], -0.5 + pos[0], 0.5 + pos[1], 0.5 + pos[2], -0.5 + pos[0], 0.5 + pos[1], 0.5 + pos[2], 0.5 + pos[0], -0.5 + pos[1], 0.5 + pos[2], 0.5 + pos[0], 0.5 + pos[1], 0.5 + pos[2]],
          norm: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
          uv: [...uv[0], ...uv[2], ...uv[1], ...uv[1], ...uv[2], ...uv[3]]
        };
      case "nx":
        return {
          pos: [0.5 + pos[0], -0.5 + pos[1], 0.5 + pos[2], 0.5 + pos[0], -0.5 + pos[1], -0.5 + pos[2], 0.5 + pos[0], 0.5 + pos[1], 0.5 + pos[2], 0.5 + pos[0], 0.5 + pos[1], 0.5 + pos[2], 0.5 + pos[0], -0.5 + pos[1], -0.5 + pos[2], 0.5 + pos[0], 0.5 + pos[1], -0.5 + pos[2]],
          norm: [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0],
          uv: [...uv[0], ...uv[2], ...uv[1], ...uv[1], ...uv[2], ...uv[3]]
        };
      case "nz":
        return {
          pos: [0.5 + pos[0], -0.5 + pos[1], -0.5 + pos[2], -0.5 + pos[0], -0.5 + pos[1], -0.5 + pos[2], 0.5 + pos[0], 0.5 + pos[1], -0.5 + pos[2], 0.5 + pos[0], 0.5 + pos[1], -0.5 + pos[2], -0.5 + pos[0], -0.5 + pos[1], -0.5 + pos[2], -0.5 + pos[0], 0.5 + pos[1], -0.5 + pos[2]],
          norm: [0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1],
          uv: [...uv[0], ...uv[2], ...uv[1], ...uv[1], ...uv[2], ...uv[3]]
        };
      case "px":
        return {
          pos: [-0.5 + pos[0], -0.5 + pos[1], -0.5 + pos[2], -0.5 + pos[0], -0.5 + pos[1], 0.5 + pos[2], -0.5 + pos[0], 0.5 + pos[1], -0.5 + pos[2], -0.5 + pos[0], 0.5 + pos[1], -0.5 + pos[2], -0.5 + pos[0], -0.5 + pos[1], 0.5 + pos[2], -0.5 + pos[0], 0.5 + pos[1], 0.5 + pos[2]],
          norm: [-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0],
          uv: [...uv[0], ...uv[2], ...uv[1], ...uv[1], ...uv[2], ...uv[3]]
        };
      case "py":
        return {
          pos: [0.5 + pos[0], 0.5 + pos[1], -0.5 + pos[2], -0.5 + pos[0], 0.5 + pos[1], -0.5 + pos[2], 0.5 + pos[0], 0.5 + pos[1], 0.5 + pos[2], 0.5 + pos[0], 0.5 + pos[1], 0.5 + pos[2], -0.5 + pos[0], 0.5 + pos[1], -0.5 + pos[2], -0.5 + pos[0], 0.5 + pos[1], 0.5 + pos[2]],
          norm: [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0],
          uv: [...uv[0], ...uv[2], ...uv[1], ...uv[1], ...uv[2], ...uv[3]]
        };
      case "ny":
        return {
          pos: [0.5 + pos[0], -0.5 + pos[1], 0.5 + pos[2], -0.5 + pos[0], -0.5 + pos[1], 0.5 + pos[2], 0.5 + pos[0], -0.5 + pos[1], -0.5 + pos[2], 0.5 + pos[0], -0.5 + pos[1], -0.5 + pos[2], -0.5 + pos[0], -0.5 + pos[1], 0.5 + pos[2], -0.5 + pos[0], -0.5 + pos[1], -0.5 + pos[2]],
          norm: [0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0],
          uv: [...uv[0], ...uv[2], ...uv[1], ...uv[1], ...uv[2], ...uv[3]]
        };
    }
  }

  genCellGeo(cellX, cellY, cellZ) {
    var _this, addFace, aoColor, colors, i, j, k, l, m, n, normals, pos, positions, ref, ref1, ref2, uvs;
    _this = this;
    positions = [];
    normals = [];
    uvs = [];
    colors = [];
    aoColor = function(type) {
      if (type === 0) {
        return [0.9, 0.9, 0.9];
      } else if (type === 1) {
        return [0.7, 0.7, 0.7];
      } else if (type === 2) {
        return [0.5, 0.5, 0.5];
      } else {
        return [0.3, 0.3, 0.3];
      }
    };
    addFace = function(type, pos) {
      var col1, col2, col3, col4, faceVertex, l, loaded, m, n, x, y, z;
      faceVertex = _this.genBlockFace(type, _this.cellTerrain.getBlock(...pos), pos);
      positions.push(...faceVertex.pos);
      normals.push(...faceVertex.norm);
      uvs.push(...faceVertex.uv);
      // _this.cellTerrain.getBlock(pos[0],pos[1],pos[2])
      loaded = {};
      for (x = l = -1; l <= 1; x = ++l) {
        for (y = m = -1; m <= 1; y = ++m) {
          for (z = n = -1; n <= 1; z = ++n) {
            if (_this.cellTerrain.getBlock(pos[0] + x, pos[1] + y, pos[2] + z).boundingBox === "block") {
              loaded[`${x}:${y}:${z}`] = 1;
            } else {
              loaded[`${x}:${y}:${z}`] = 0;
            }
          }
        }
      }
      col1 = aoColor(0);
      col2 = aoColor(0);
      col3 = aoColor(0);
      col4 = aoColor(0);
      if (type === "py") {
        col1 = aoColor(loaded["1:1:-1"] + loaded["0:1:-1"] + loaded["1:1:0"]);
        col2 = aoColor(loaded["1:1:1"] + loaded["0:1:1"] + loaded["1:1:0"]);
        col3 = aoColor(loaded["-1:1:-1"] + loaded["0:1:-1"] + loaded["-1:1:0"]);
        col4 = aoColor(loaded["-1:1:1"] + loaded["0:1:1"] + loaded["-1:1:0"]);
      }
      if (type === "ny") {
        col2 = aoColor(loaded["1:-1:-1"] + loaded["0:-1:-1"] + loaded["1:-1:0"]);
        col1 = aoColor(loaded["1:-1:1"] + loaded["0:-1:1"] + loaded["1:-1:0"]);
        col4 = aoColor(loaded["-1:-1:-1"] + loaded["0:-1:-1"] + loaded["-1:-1:0"]);
        col3 = aoColor(loaded["-1:-1:1"] + loaded["0:-1:1"] + loaded["-1:-1:0"]);
      }
      if (type === "px") {
        col1 = aoColor(loaded["-1:-1:0"] + loaded["-1:-1:-1"] + loaded["-1:0:-1"]);
        col2 = aoColor(loaded["-1:1:0"] + loaded["-1:1:-1"] + loaded["-1:0:-1"]);
        col3 = aoColor(loaded["-1:-1:0"] + loaded["-1:-1:1"] + loaded["-1:0:1"]);
        col4 = aoColor(loaded["-1:1:0"] + loaded["-1:1:1"] + loaded["-1:0:1"]);
      }
      if (type === "nx") {
        col3 = aoColor(loaded["1:-1:0"] + loaded["1:-1:-1"] + loaded["1:0:-1"]);
        col4 = aoColor(loaded["1:1:0"] + loaded["1:1:-1"] + loaded["1:0:-1"]);
        col1 = aoColor(loaded["1:-1:0"] + loaded["1:-1:1"] + loaded["1:0:1"]);
        col2 = aoColor(loaded["1:1:0"] + loaded["1:1:1"] + loaded["1:0:1"]);
      }
      if (type === "pz") {
        col1 = aoColor(loaded["0:-1:1"] + loaded["-1:-1:1"] + loaded["-1:0:1"]);
        col2 = aoColor(loaded["0:1:1"] + loaded["-1:1:1"] + loaded["-1:0:1"]);
        col3 = aoColor(loaded["0:-1:1"] + loaded["1:-1:1"] + loaded["1:0:1"]);
        col4 = aoColor(loaded["0:1:1"] + loaded["1:1:1"] + loaded["1:0:1"]);
      }
      if (type === "nz") {
        col3 = aoColor(loaded["0:-1:-1"] + loaded["-1:-1:-1"] + loaded["-1:0:-1"]);
        col4 = aoColor(loaded["0:1:-1"] + loaded["-1:1:-1"] + loaded["-1:0:-1"]);
        col1 = aoColor(loaded["0:-1:-1"] + loaded["1:-1:-1"] + loaded["1:0:-1"]);
        col2 = aoColor(loaded["0:1:-1"] + loaded["1:1:-1"] + loaded["1:0:-1"]);
      }
      colors.push(...col1, ...col3, ...col2, ...col2, ...col3, ...col4);
    };
    for (i = l = 0, ref = this.cellSize - 1; (0 <= ref ? l <= ref : l >= ref); i = 0 <= ref ? ++l : --l) {
      for (j = m = 0, ref1 = this.cellSize - 1; (0 <= ref1 ? m <= ref1 : m >= ref1); j = 0 <= ref1 ? ++m : --m) {
        for (k = n = 0, ref2 = this.cellSize - 1; (0 <= ref2 ? n <= ref2 : n >= ref2); k = 0 <= ref2 ? ++n : --n) {
          pos = [cellX * this.cellSize + i, cellY * this.cellSize + j, cellZ * this.cellSize + k];
          if (this.cellTerrain.getBlock(...pos).boundingBox === "block") {
            if (this.cellTerrain.getBlock(pos[0] + 1, pos[1], pos[2]).boundingBox !== "block") {
              addFace("nx", pos);
            }
            if (this.cellTerrain.getBlock(pos[0] - 1, pos[1], pos[2]).boundingBox !== "block") {
              addFace("px", pos);
            }
            if (this.cellTerrain.getBlock(pos[0], pos[1] - 1, pos[2]).boundingBox !== "block") {
              addFace("ny", pos);
            }
            if (this.cellTerrain.getBlock(pos[0], pos[1] + 1, pos[2]).boundingBox !== "block") {
              addFace("py", pos);
            }
            if (this.cellTerrain.getBlock(pos[0], pos[1], pos[2] + 1).boundingBox !== "block") {
              addFace("pz", pos);
            }
            if (this.cellTerrain.getBlock(pos[0], pos[1], pos[2] - 1).boundingBox !== "block") {
              addFace("nz", pos);
            }
          } else if (this.cellTerrain.getBlock(...pos).name === "water") {
            if (this.cellTerrain.getBlock(pos[0] + 1, pos[1], pos[2]).name === "air") {
              addFace("nx", pos);
            }
            if (this.cellTerrain.getBlock(pos[0] - 1, pos[1], pos[2]).name === "air") {
              addFace("px", pos);
            }
            if (this.cellTerrain.getBlock(pos[0], pos[1] - 1, pos[2]).name === "air") {
              addFace("ny", pos);
            }
            if (this.cellTerrain.getBlock(pos[0], pos[1] + 1, pos[2]).name === "air") {
              addFace("py", pos);
            }
            if (this.cellTerrain.getBlock(pos[0], pos[1], pos[2] + 1).name === "air") {
              addFace("pz", pos);
            }
            if (this.cellTerrain.getBlock(pos[0], pos[1], pos[2] - 1).name === "air") {
              addFace("nz", pos);
            }
          }
        }
      }
    }
    return {positions, normals, uvs, colors};
  }

};

addEventListener("message", function(e) {
  var fn;
  fn = handlers[e.data.type];
  if (!fn) {
    throw new Error('no handler for type: ' + e.data.type);
  }
  fn(e.data.data);
});

State = {
  init: null,
  world: {}
};

terrain = null;

time = 0;

handlers = {
  init: function(data) {
    State.init = data;
    terrain = new TerrainManager({
      models: data.models,
      blocks: data.blocks,
      blocksMapping: data.blocksMapping,
      toxelSize: data.toxelSize,
      cellSize: data.cellSize
    });
  },
  setVoxel: function(data) {
    return terrain.cellTerrain.setVoxel(...data);
  },
  genCellGeo: function(data) {
    var geo;
    if (((terrain.cellTerrain.vec3(...data)) in terrain.cellTerrain.cells) === true) {
      geo = terrain.genCellGeo(...data);
      return postMessage({
        cell: geo,
        info: data
      });
    }
  },
  setCell: function(data) {
    return terrain.cellTerrain.setCell(data[0], data[1], data[2], data[3]);
  }
};
