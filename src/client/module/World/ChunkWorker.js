// Generated by CoffeeScript 2.5.1
var State, TerrainManager, handlers, terrain, time;

import {
  CellTerrain
} from './CellTerrain.js';

console.log("CHUNK WORKER STARTED!");

TerrainManager = class TerrainManager {
  constructor(options) {
    this.toxelSize = options.toxelSize;
    this.q = 1 / this.toxelSize;
    this.blocks = options.blocks;
    this.blocksMapping = options.blocksMapping;
    this.cellSize = options.cellSize;
    this.models = options.models;
    this.cellTerrain = new CellTerrain({
      cellSize: this.cellSize
    });
  }

  getToxel(x, y) {
    var x1, x2, y1, y2;
    x -= 1;
    y -= 1;
    x1 = this.q * x;
    y1 = 1 - this.q * y - this.q;
    x2 = this.q * x + this.q;
    y2 = 1 - this.q * y;
    return [[x1, y1], [x1, y2], [x2, y1], [x2, y2]];
  }

  genBlockFace(type, voxel, pos) {
    var blockName, toxX, toxY, uv;
    // toxX=@blocksMapping["debug"]["x"]
    // toxY=28-@blocksMapping["debug"]["y"]
    if (this.blocks[voxel] === void 0) {
      toxX = this.blocksMapping["debug"]["x"];
      toxY = 28 - this.blocksMapping["debug"]["y"];
    } else {
      blockName = this.blocks[voxel]["faces"][type];
      toxX = this.blocksMapping[blockName]["x"];
      toxY = this.blocksMapping[blockName]["y"];
    }
    uv = this.getToxel(toxX, toxY);
    switch (type) {
      case "pz":
        return {
          pos: [-0.5 + pos[0], -0.5 + pos[1], 0.5 + pos[2], 0.5 + pos[0], -0.5 + pos[1], 0.5 + pos[2], -0.5 + pos[0], 0.5 + pos[1], 0.5 + pos[2], -0.5 + pos[0], 0.5 + pos[1], 0.5 + pos[2], 0.5 + pos[0], -0.5 + pos[1], 0.5 + pos[2], 0.5 + pos[0], 0.5 + pos[1], 0.5 + pos[2]],
          norm: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
          uv: [...uv[0], ...uv[2], ...uv[1], ...uv[1], ...uv[2], ...uv[3]]
        };
      case "nx":
        return {
          pos: [0.5 + pos[0], -0.5 + pos[1], 0.5 + pos[2], 0.5 + pos[0], -0.5 + pos[1], -0.5 + pos[2], 0.5 + pos[0], 0.5 + pos[1], 0.5 + pos[2], 0.5 + pos[0], 0.5 + pos[1], 0.5 + pos[2], 0.5 + pos[0], -0.5 + pos[1], -0.5 + pos[2], 0.5 + pos[0], 0.5 + pos[1], -0.5 + pos[2]],
          norm: [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0],
          uv: [...uv[0], ...uv[2], ...uv[1], ...uv[1], ...uv[2], ...uv[3]]
        };
      case "nz":
        return {
          pos: [0.5 + pos[0], -0.5 + pos[1], -0.5 + pos[2], -0.5 + pos[0], -0.5 + pos[1], -0.5 + pos[2], 0.5 + pos[0], 0.5 + pos[1], -0.5 + pos[2], 0.5 + pos[0], 0.5 + pos[1], -0.5 + pos[2], -0.5 + pos[0], -0.5 + pos[1], -0.5 + pos[2], -0.5 + pos[0], 0.5 + pos[1], -0.5 + pos[2]],
          norm: [0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1],
          uv: [...uv[0], ...uv[2], ...uv[1], ...uv[1], ...uv[2], ...uv[3]]
        };
      case "px":
        return {
          pos: [-0.5 + pos[0], -0.5 + pos[1], -0.5 + pos[2], -0.5 + pos[0], -0.5 + pos[1], 0.5 + pos[2], -0.5 + pos[0], 0.5 + pos[1], -0.5 + pos[2], -0.5 + pos[0], 0.5 + pos[1], -0.5 + pos[2], -0.5 + pos[0], -0.5 + pos[1], 0.5 + pos[2], -0.5 + pos[0], 0.5 + pos[1], 0.5 + pos[2]],
          norm: [-1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0],
          uv: [...uv[0], ...uv[2], ...uv[1], ...uv[1], ...uv[2], ...uv[3]]
        };
      case "py":
        return {
          pos: [0.5 + pos[0], 0.5 + pos[1], -0.5 + pos[2], -0.5 + pos[0], 0.5 + pos[1], -0.5 + pos[2], 0.5 + pos[0], 0.5 + pos[1], 0.5 + pos[2], 0.5 + pos[0], 0.5 + pos[1], 0.5 + pos[2], -0.5 + pos[0], 0.5 + pos[1], -0.5 + pos[2], -0.5 + pos[0], 0.5 + pos[1], 0.5 + pos[2]],
          norm: [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0],
          uv: [...uv[0], ...uv[2], ...uv[1], ...uv[1], ...uv[2], ...uv[3]]
        };
      case "ny":
        return {
          pos: [0.5 + pos[0], -0.5 + pos[1], 0.5 + pos[2], -0.5 + pos[0], -0.5 + pos[1], 0.5 + pos[2], 0.5 + pos[0], -0.5 + pos[1], -0.5 + pos[2], 0.5 + pos[0], -0.5 + pos[1], -0.5 + pos[2], -0.5 + pos[0], -0.5 + pos[1], 0.5 + pos[2], -0.5 + pos[0], -0.5 + pos[1], -0.5 + pos[2]],
          norm: [0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0],
          uv: [...uv[0], ...uv[2], ...uv[1], ...uv[1], ...uv[2], ...uv[3]]
        };
    }
  }

  genCellGeo(cellX, cellY, cellZ) {
    var _this, addFace, addGeo, geo, i, j, k, l, m, n, normals, pos, positions, ref, ref1, ref2, uvs, voxel;
    positions = [];
    normals = [];
    uvs = [];
    _this = this;
    addFace = function(type, pos, voxel) {
      var faceVertex;
      faceVertex = _this.genBlockFace(type, voxel, pos);
      positions.push(...faceVertex.pos);
      normals.push(...faceVertex.norm);
      uvs.push(...faceVertex.uv);
    };
    addGeo = function(geo, pos) {
      var i, l, norm, posi, ref, uv;
      posi = geo.position.array;
      norm = geo.normal.array;
      uv = geo.uv.array;
      for (i = l = 0, ref = posi.length - 1; (0 <= ref ? l <= ref : l >= ref); i = 0 <= ref ? ++l : --l) {
        positions.push(posi[i] + pos[i % 3]);
      }
      normals.push(...norm);
      uvs.push(...uv);
    };
    for (i = l = 0, ref = this.cellSize - 1; (0 <= ref ? l <= ref : l >= ref); i = 0 <= ref ? ++l : --l) {
      for (j = m = 0, ref1 = this.cellSize - 1; (0 <= ref1 ? m <= ref1 : m >= ref1); j = 0 <= ref1 ? ++m : --m) {
        for (k = n = 0, ref2 = this.cellSize - 1; (0 <= ref2 ? n <= ref2 : n >= ref2); k = 0 <= ref2 ? ++n : --n) {
          pos = [cellX * this.cellSize + i, cellY * this.cellSize + j, cellZ * this.cellSize + k];
          voxel = this.getVoxel(...pos);
          if (voxel) {
            if (this.blocks[voxel] === void 0 || this.blocks[voxel].isBlock) {
              if (!(this.blocks[this.getVoxel(pos[0] + 1, pos[1], pos[2])] === void 0 || this.blocks[this.getVoxel(pos[0] + 1, pos[1], pos[2])].isBlock)) {
                addFace("nx", pos, voxel);
              }
              if (!(this.blocks[this.getVoxel(pos[0] - 1, pos[1], pos[2])] === void 0 || this.blocks[this.getVoxel(pos[0] - 1, pos[1], pos[2])].isBlock)) {
                addFace("px", pos, voxel);
              }
              if (!(this.blocks[this.getVoxel(pos[0], pos[1] - 1, pos[2])] === void 0 || this.blocks[this.getVoxel(pos[0], pos[1] - 1, pos[2])].isBlock)) {
                addFace("ny", pos, voxel);
              }
              if (!(this.blocks[this.getVoxel(pos[0], pos[1] + 1, pos[2])] === void 0 || this.blocks[this.getVoxel(pos[0], pos[1] + 1, pos[2])].isBlock)) {
                addFace("py", pos, voxel);
              }
              if (!(this.blocks[this.getVoxel(pos[0], pos[1], pos[2] + 1)] === void 0 || this.blocks[this.getVoxel(pos[0], pos[1], pos[2] + 1)].isBlock)) {
                addFace("pz", pos, voxel);
              }
              if (!(this.blocks[this.getVoxel(pos[0], pos[1], pos[2] - 1)] === void 0 || this.blocks[this.getVoxel(pos[0], pos[1], pos[2] - 1)].isBlock)) {
                addFace("nz", pos, voxel);
              }
            } else {
              geo = this.models[this.blocks[voxel].model];
              addGeo(geo, pos);
            }
          }
        }
      }
    }
    return {positions, normals, uvs};
  }

  setVoxel(voxelX, voxelY, voxelZ, value) {
    this.cellTerrain.setVoxel(voxelX, voxelY, voxelZ, value);
  }

  getVoxel(voxelX, voxelY, voxelZ) {
    return this.cellTerrain.getVoxel(voxelX, voxelY, voxelZ);
  }

};

addEventListener("message", function(e) {
  var fn;
  fn = handlers[e.data.type];
  if (!fn) {
    throw new Error('no handler for type: ' + e.data.type);
  }
  fn(e.data.data);
});

State = {
  init: null,
  world: {}
};

terrain = null;

time = 0;

handlers = {
  init: function(data) {
    State.init = data;
    terrain = new TerrainManager({
      models: data.models,
      blocks: data.blocks,
      blocksMapping: data.blocksMapping,
      toxelSize: data.toxelSize,
      cellSize: data.cellSize
    });
  },
  setVoxel: function(data) {
    return terrain.setVoxel(...data);
  },
  genCellGeo: function(data) {
    var geo, t0, t1;
    if (((terrain.cellTerrain.vec3(...data)) in terrain.cellTerrain.cells) === true) {
      t0 = performance.now();
      geo = terrain.genCellGeo(...data);
      t1 = performance.now();
      time += t1 - t0;
      console.log(time);
      return postMessage({
        cell: geo,
        info: data
      });
    }
  },
  setCell: function(data) {
    console.log("Otrzymano komórkę");
    return terrain.cellTerrain.cells[`${data[0]}:${data[1]}:${data[2]}`] = data[3];
  }
};
